{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"e5e6a6649cf3ac7e7d5bc69203cbceb334efa5d4","modified":1669865382000},{"_id":"source/_posts/笔记：51单片机.md","hash":"8db62a5f0c97719c1e33c3e9bbef3c5e66809fb5","modified":1683420708000},{"_id":"source/_posts/笔记：堆和栈的区别.md","hash":"123f4dd59d1e51b4c7185783ce83874014ea2005","modified":1679733512000},{"_id":"source/_posts/笔记：类和结构的区别.md","hash":"88edc1d8023fd4a0ed4c00dae2c33f430d78dbb3","modified":1679733670000},{"_id":"source/_posts/继承以及单、双继承的含义以及区别.md","hash":"2a7fa50eb735c865dff3bbd8f449ad3622451fbe","modified":1679733672000},{"_id":"source/about/index.md","hash":"fb17e37222b17f5245c54bb6beea960486c85ad7","modified":1669863422000},{"_id":"source/categories/index.md","hash":"4ce06a6885fab1274e11273562be9faec2e0976d","modified":1669863878000},{"_id":"source/css/custom.css","hash":"2fc60914d6e055b13d217d1db06ec681349fb125","modified":1669968546000},{"_id":"source/link/index.md","hash":"d76e3f1473dda434b30c4be0a21f0dd5e47f9c9a","modified":1669863420000},{"_id":"source/movies/index.md","hash":"abf0baca81b3e4dfb7188085566c6af8b59beb64","modified":1669863422000},{"_id":"source/music/index.md","hash":"b0c77c2a7c8d25a22cdc60f0f97be93919a97ead","modified":1669863182000},{"_id":"source/tags/index.md","hash":"8d950d9e2dd44d35e4988707e22f468268dd686e","modified":1669864094000},{"_id":"themes/Butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1669819080000},{"_id":"themes/Butterfly/README.md","hash":"c34579d9d7239828ce7d8abc235521eaf4ea9e17","modified":1669819080000},{"_id":"themes/Butterfly/README_CN.md","hash":"25cfdbaf9883095322259c4f49bd08f0a7cffa0e","modified":1669819080000},{"_id":"themes/Butterfly/package.json","hash":"d2de76d6c4fbf9d6b329bba8ba808f7ccbd613fa","modified":1669819080000},{"_id":"themes/Butterfly/plugins.yml","hash":"d46811a3c50f7057681ac496de4beda107aa26b6","modified":1669819080000},{"_id":"themes/Butterfly/languages/default.yml","hash":"1e37a3695d50e3e61d7c36e58a6dac872a4a56cd","modified":1669819080000},{"_id":"themes/Butterfly/languages/en.yml","hash":"d1bb560698eb8b0079495b7b18b44facb610f9fd","modified":1669819080000},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"28b6f0c39155651d747eb595e0a283bc97be2e09","modified":1669819080000},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"947f794e862bb2813e36887f777bdb760f70a322","modified":1669819080000},{"_id":"themes/Butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1669819080000},{"_id":"themes/Butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1669819080000},{"_id":"themes/Butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1669819080000},{"_id":"themes/Butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1669819080000},{"_id":"themes/Butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1669819080000},{"_id":"themes/Butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1669819080000},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1669819080000},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1669819080000},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1669819080000},{"_id":"themes/Butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1669819080000},{"_id":"themes/Butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"346b6b650b9dee4844f3be7865886002f82da24c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"7dee9b73acdec2a34d41a45119ebe8bb8650bf6c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"919020d4cd7ae68694b2326edeed4328c7f933cd","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"699d0d2cff233628752956c4434125c8203f7d63","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1669819080000},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1669819080000},{"_id":"themes/Butterfly/scripts/events/cdn.js","hash":"acfe765fb2c607bff7198630dbfa53a888c36357","modified":1669819080000},{"_id":"themes/Butterfly/scripts/events/comment.js","hash":"a3d1f417965ca20253c36f9e93429f3df6268856","modified":1669819080000},{"_id":"themes/Butterfly/scripts/events/init.js","hash":"b4940a5c73d3a5cd8bb5883e3041ecdd905a74e0","modified":1669819080000},{"_id":"themes/Butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1669819080000},{"_id":"themes/Butterfly/scripts/events/welcome.js","hash":"3cfc46c749e2fd7ae9c2a17206238ed0e0e17e7d","modified":1669819080000},{"_id":"themes/Butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1669819080000},{"_id":"themes/Butterfly/scripts/filters/random_cover.js","hash":"21379ed2dccb69c43b893895c9d56238c11e5f43","modified":1669819080000},{"_id":"themes/Butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1669819080000},{"_id":"themes/Butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1669819080000},{"_id":"themes/Butterfly/scripts/helpers/findArchiveLength.js","hash":"ee3e70098eb0849497d50b75e18cf4a27c397d52","modified":1669819080000},{"_id":"themes/Butterfly/scripts/helpers/inject_head_js.js","hash":"b4cd617c619d1a0df93603721a6fa1317526174b","modified":1669819080000},{"_id":"themes/Butterfly/scripts/helpers/page.js","hash":"763dab5c83f50c1c62fffc9a9dfedea29bb4e629","modified":1669819080000},{"_id":"themes/Butterfly/scripts/helpers/related_post.js","hash":"d368a8830e506c8b5eb6512b709ec8db354d5ea1","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/gallery.js","hash":"f79c99f6c5b626c272dc2bed2b0250d6b91bb28a","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1669819080000},{"_id":"themes/Butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1669819080000},{"_id":"themes/Butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1669819080000},{"_id":"themes/Butterfly/source/css/var.styl","hash":"e018dad9f674fc5564112b99032fe5fe8b2d195f","modified":1669819080000},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1669819080000},{"_id":"themes/Butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1669819080000},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1669819080000},{"_id":"themes/Butterfly/source/js/main.js","hash":"189359400f6cd4d814ca9ebb5a27b96f7031bce3","modified":1669819080000},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"5c1391c9e96950833641f178b5f23c58422fb659","modified":1669819080000},{"_id":"themes/Butterfly/source/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"fe4d847177b824e09c75e9c7b723184c708c569a","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"15530d9ac59c576d79af75dd687efe71e8d261b0","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"2df5a033104775ee9c8715925bb32c3ec5b75da0","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/preconnect.pug","hash":"65a23b5170204e55b813ce13a79d799b66b7382c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"aa175e2254704335f4da09175e59ef2375ca7d03","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/header/nav.pug","hash":"78a3abd90bb3c18cd773d3d5abac3541e7f415e5","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/loading/pace.pug","hash":"278855fe4399489bdef0393697bb87420e671fe9","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/mixins/post-ui.pug","hash":"6ae047d566289294cc2f6192cacbff297cec9f1a","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/loading/fullpage-loading.pug","hash":"c4b86758f3a3deae4612c31d725814c8753a7804","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/page/flink.pug","hash":"e3d574921fca8e756923bf3b303835e57b9a26b2","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/page/tags.pug","hash":"6311eda08e4515281c51bd49f43902a51832383c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/pjax.pug","hash":"fc0b09068009edd4026d90a669608cbe211aeecf","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/subtitle.pug","hash":"142621f70bedcb5033ee99a988f7bb6c5eea3493","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"7fb096656c8a6c21a4b6a5100885b1081d6021ed","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_global/function.styl","hash":"644d520fe80cc82058467708ab82ccad313b0c27","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"714f19e7d66df84938bd1b82b33d5667abe1f147","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"a0010d833ed30211601c1e0bbbc68e85b77428c6","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"26be2afa9d4e7016cf3c42a6cd166f01e8e4ad5c","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"a457a0dbe23af21a7b6b8bfc5ee103c9fe92e89c","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"23db4e3cab68fed78601fc8a9c39ff5753bcc716","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"56389925671c7e8da0c033769421269e15e8f795","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"bd88ee30ebf8ca2e7b4d3a034c317fd61733921f","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"a92984f566c97bb4179f34be79240af1552c6f17","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"69f8e9414526dfda3af9a71c8e528fdd0ecbbfe5","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_page/archives.styl","hash":"6f4b4ede52305bce9b22c8c897dcbde8af6e2ce4","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_page/common.styl","hash":"a58d35d698885f1034dedbe99f7dbc1a801412c6","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_page/homepage.styl","hash":"8c90483d461e09cb06e91b16d8bb7b3205b0a40c","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"51e45625929d57c9df3ba9090af99b9b7bb9a15b","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"39d61cbe0c1e937f83ba3b147afaa29b4de2f87d","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"25e58a7a8bda4b73d0a0e551643ca01b09ccd7e5","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/gallery.styl","hash":"a310e48f826a4cacc55d8e68f43806e5085554f6","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1669819080000},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"9feb248552667c53ce1b19bc7a295215f8c77008","modified":1669819080000},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"99d9b17668260b242749c16851d9ec1024d31899","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"b2aadea7351fae8382b8c2a3b9de810d922b0ec1","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"58406a7a3bf45815769f652bf3ef81e57dcd07eb","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"5f648086a33a32d169a2f8d8c549c08aa02f67db","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/chat/index.pug","hash":"0611d9216f4c128ebdea4cc21454c3dc4a6398d5","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/chat/messenger.pug","hash":"ccb7d8ce3ded7364f9a15334b68ad73869fca757","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/artalk.pug","hash":"49dcc23815e1d5264bb65c91e7dc67b1a723d1ea","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/disqus.pug","hash":"8ec24c1939895ac0db2b2e8700bc9307b4ceb53c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"98ef20f8a3b10c1692f9b2b3c06033d2da8a8eae","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"eefdaa94956adc7a3ca90dd8edcd70a7574b439c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/giscus.pug","hash":"591ef23c583690bd74af0cafb09af64ba5bd8151","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"22e2ef30fe5eb1db7566e89943c74ece029b2a8e","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/index.pug","hash":"351fe25fbf02635b1f9e86e5e244c7d61f69baa7","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/remark42.pug","hash":"e9bdf80d6796afc04eb809dbbe780d97f22c7fcd","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"e18fbd88d8942e53e771f29b26209ab735c5c567","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/comments/waline.pug","hash":"15462d1ed04651ad3b430c682842ac400f6f9b47","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/math/mathjax.pug","hash":"1c846c8d51649b8554d91536323eaeb20c8fc236","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/math/mermaid.pug","hash":"8e33aca36a4d3ae9e041ba05ced8eff56ae38f77","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"c12c898b35dd014780c1f3220ddbe12e7270983c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"ab167c00da4506f591b96f0591bf5bd214a26d4b","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"233907dd7f5b5f33412701d2ccffbc0bbae8707b","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"dd0bc119029b62dce5dc965d5de7377e438fa29a","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/search/algolia.pug","hash":"e8245d0b4933129bb1c485d8de11a9e52e676348","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/search/local-search.pug","hash":"178c9cdcc4ce5a006885b24ce4a3d624e4734899","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1669819080000},{"_id":"themes/Butterfly/layout/includes/third-party/share/share-js.pug","hash":"f61d63724ea5c5f352568b3a16bde023affefbe5","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1669819080000},{"_id":"themes/Butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1669819080000},{"_id":"public/css/custom.css","hash":"30a41bf8495adcb1d4a1bc1f8d7f5e16657e5643","modified":1702117651433},{"_id":"public/about/index.html","hash":"d49b8f309341f23b2b6ed713dfe75002cc3ffb25","modified":1702117651433},{"_id":"public/categories/index.html","hash":"6450e66442965991feae769afffd6aef8cd6c9cc","modified":1702117651433},{"_id":"public/link/index.html","hash":"30538705403c59f96f04ec8c08cd58304214fe3a","modified":1702117651433},{"_id":"public/movies/index.html","hash":"19a41a1dd8e700bb622e1149f1614e35cf703154","modified":1702117651433},{"_id":"public/music/index.html","hash":"561ff87d439f3d48873c2ec8a4420b95e243089c","modified":1702117651433},{"_id":"public/tags/index.html","hash":"47a7bab7be81bbb9c2e6ee74c3644755e26afb7b","modified":1702117651433},{"_id":"public/2023/12/09/笔记：堆和栈的区别/index.html","hash":"8addb62b7b38bae971d10b667c1690175b30bd05","modified":1702117651433},{"_id":"public/2023/12/09/hello-world/index.html","hash":"603be5f1fe50a000e6f4be97e95b3468bb30eea7","modified":1702117651433},{"_id":"public/2023/12/09/笔记：类和结构的区别/index.html","hash":"5721fecc1da859a57bf409444ddec4a6ef2cd339","modified":1702117651433},{"_id":"public/2023/12/09/笔记：51单片机/index.html","hash":"b21f79cece809a4b64a8c8ef6be0a668ee60a647","modified":1702117651433},{"_id":"public/2023/12/09/继承以及单、双继承的含义以及区别/index.html","hash":"a758af66e4627b950727128839c7796e677bd546","modified":1702117651433},{"_id":"public/archives/index.html","hash":"b308b3eaabf9d452ca535400243a155b94aa91d0","modified":1702117651433},{"_id":"public/archives/2023/index.html","hash":"5921a061506ba6b6d114f432153c6af29364dc55","modified":1702117651433},{"_id":"public/archives/2023/12/index.html","hash":"d1d1b7058a40bd63643a41397a4ad6329ff11cb5","modified":1702117651433},{"_id":"public/index.html","hash":"d61d88799b1754610a1c7f59399b5d176d2bc095","modified":1702117651433},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1702117651433},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1702117651433},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1702117651433},{"_id":"public/css/index.css","hash":"5fc244bce32ad84a1d4ee0076b0a78d007c4ae3e","modified":1702117651433},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1702117651433},{"_id":"public/js/main.js","hash":"189359400f6cd4d814ca9ebb5a27b96f7031bce3","modified":1702117651433},{"_id":"public/js/tw_cn.js","hash":"5c1391c9e96950833641f178b5f23c58422fb659","modified":1702117651433},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1702117651433},{"_id":"public/js/search/algolia.js","hash":"9feb248552667c53ce1b19bc7a295215f8c77008","modified":1702117651433},{"_id":"public/js/search/local-search.js","hash":"3071a4208fdf89ad7e0031536dd6ffa7bc951e4d","modified":1702117651433}],"Category":[],"Data":[],"Page":[{"title":"关于","date":"2022-12-01T02:40:00.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2022-12-1 10:40:00\n---","updated":"2022-12-01T02:57:02.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"clpxwwhyw0000lc4deacretlz","content":"","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":""},{"title":"分类","date":"2022-12-01T02:40:00.000Z","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-12-1 10:40:00\n---","updated":"2022-12-01T03:04:38.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clpxwwhz30002lc4dg8ze20b0","content":"","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":""},{"_content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","source":"css/custom.css","raw":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","date":"2023-12-09T10:24:12.675Z","updated":"2022-12-02T08:09:06.000Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"clpxwwhz50004lc4d0no8bjve","content":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":"/* 页脚与头图透明 */\n#footer {\n    background: transparent !important;\n  }\n  #page-header {\n    background: transparent !important;\n  }\n  \n  /* 白天模式遮罩透明 */\n  #footer::before {\n    background: transparent !important;\n  }\n  #page-header::before {\n    background: transparent !important;\n  }\n  \n  /* 夜间模式遮罩透明 */\n  [data-theme=\"dark\"] #footer::before {\n    background: transparent !important;\n  }\n  [data-theme=\"dark\"] #page-header::before {\n    background: transparent !important;\n  }"},{"title":"友链","date":"2022-12-01T02:40:00.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: 友链\ndate: 2022-12-1 10:40:00\ntype: \"link\"\n---","updated":"2022-12-01T02:57:00.000Z","path":"link/index.html","comments":1,"layout":"page","_id":"clpxwwhz70006lc4d4vhp65gi","content":"","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":""},{"title":"电影","date":"2022-12-01T02:40:00.000Z","_content":"","source":"movies/index.md","raw":"---\ntitle: 电影\ndate: 2022-12-1 10:40:00\n---","updated":"2022-12-01T02:57:02.000Z","path":"movies/index.html","comments":1,"layout":"page","_id":"clpxwwhz80008lc4d6c86e2xr","content":"","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":""},{"title":"音乐","date":"2022-12-01T02:40:00.000Z","_content":"","source":"music/index.md","raw":"---\ntitle: 音乐\ndate: 2022-12-1 10:40:00\n---","updated":"2022-12-01T02:53:02.000Z","path":"music/index.html","comments":1,"layout":"page","_id":"clpxwwhz9000alc4d6w6899y4","content":"","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":""},{"title":"标签","date":"2022-12-01T02:40:00.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-12-1 10:40:00\n---","updated":"2022-12-01T03:08:14.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clpxwwhza000blc4d9yq06meu","content":"","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post LF\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy \n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post LF\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy \n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n","slug":"hello-world","published":1,"date":"2023-12-09T10:24:12.691Z","updated":"2022-12-01T03:29:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpxwwhyz0001lc4d4ykuc76b","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post LF&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy </span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post LF&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy </span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"笔记：51单片机","_content":"\n# 51单片机笔记\n\n\n\n# 软件准备\n\n\n\n## Keil5\n\n用于单片机的源码编写和编译，去官网下载注意使用C51版本\n\n\n\n####  1.官网下载\n\n前往 Https://www.keil.com 下载\n\n####  2.白嫖资料包\n\n江科大的资料包\n\n百度网盘:https://pan.baidu.com/share/init?surl=vDTN2o8ffvczzNQGfyjHng\n\n密码:gdzff\n\n###### 注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\n\n在安装后，打开目录找到`TOOLS.INI `找到PATH项，修改路径为安装路径\n\n#### 3.Keil5的破解\n\n##### 1.在安装包中打开KEIL_LIC破解程序运行\n\n[![Keil破解教程-1.png](https://bu.dusays.com/2023/05/07/6456ea7893efc.png)](https://bu.dusays.com/2023/05/07/6456ea7893efc.png)\n\n##### 2.将Keil5以管理员身份运行\n\n##### 3.打开后点击Feil中的License Management项，查看License Management窗口右上角的computer ID中的CID，将其复制\n\n##### 4.在KEIL_LIC的CID栏粘贴后点击下方Generate\n\n[![Keil破解教程-2.png](https://bu.dusays.com/2023/05/07/6456eb972a253.png)](https://bu.dusays.com/2023/05/07/6456eb972a253.png)\n\n#### 5.复制到Keil5的LIC，点击Add LIC，完成破解\n\n\n\n------\n\n\n\n\n\n## STC-ISP烧录软件与USB驱动\n\n### STC-ISP软件\n\n在资料包中，STC-ISP可直接复制至桌面\n\n### USB驱动\n\n打开“stc-isp\\USB to UART Driver\\CH340_CH341”文件夹，双击运行ch341ser.exe程序，默认安装即可，等待“驱动安装成功”窗口弹出即可\n\n###### 在C盘可以找到\"WCH.CN文件夹“即为安装成功\n\n\n\n\n\n------\n\n\n\n\n\n# 单片机介绍\n\n\n\n### 单片机定义\n\n- 单片机，英文“Micro Controller Unit“,简称MCU\n\n- 内部集成了CPU、RAM、ROM、定时器、终端系统、通讯接口等一系列电脑的常用硬件功能\n- 单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如点击，LED等）的控制\n- 单片机和计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，也是了解计算机原理与结构的最佳选择\n\n\n\n### STC89C52RC单片机参数\n\n淘宝普遍使用的是普中科技的开发板，芯片是带RC结尾，与江科大的公开课使用的开发板略有差异，并无过大差异\n\n- 所属系列：51单片机系列\n- 公司：STC公司\n- 位数：8位\n- RAM：512字节\n- ROM：8K（Flash）\n- 工作频率：11.0592MHz（晶振频率）\n\n\n\n### 51单片机名称的由来\n\n51单片机是指使用80年代Intel开发的8051单片机内核的统称。\n\n也指对所有兼容Intel 8031指令系统的单片机的统称。\n\n\n\n### 命名规则\n\n[![STC89C52命名规则.png](https://bu.dusays.com/2023/05/07/6456ea789e436.png)](https://bu.dusays.com/2023/05/07/6456ea789e436.png)\n\n------\n\n\n\n# 练习工程\n\n\n\n## 1-1 点亮LED\n\n\n\n### 1.创建工程\n\n运行Keil5后，在上侧工具栏中点击`Project`中的`New μVision Project`项，自选一个文件位置存放项目，同样要手动创建新的文件夹。\n\n创建后会跳出选择CPU的窗口，选择`AT89C52`（不同公司的生产，但是具体参数一样）\n\n[![点亮LED-创建工程-1.png](https://bu.dusays.com/2023/05/07/6456ea788df6b.png)](https://bu.dusays.com/2023/05/07/6456ea788df6b.png)\n\n创建后应当弹出本窗口，未弹出应当检查`TOOLS.INI`配置文件中的`PATH`项是否更改为正确的程序路径\n\n 创建成功后在侧边栏按照下列路径右键`Source Group 1`\n\n[![点亮LED-创建工程-2.png](https://bu.dusays.com/2023/05/07/6456ea789f80c.png)](https://bu.dusays.com/2023/05/07/6456ea789f80c.png)\n\n选择`Add New Item to Group 'Source Group1'`\n\n[![点亮LED-创建工程-3.png](https://bu.dusays.com/2023/05/07/6456ea797f18b.png)](https://bu.dusays.com/2023/05/07/6456ea797f18b.png)\n\n在下面选择\"C File(. c)\"文件(可用不同语言，本笔记使用的语言是C)-`name`填写`main`\n\n[![点亮LED-创建工程-4.png](https://bu.dusays.com/2023/05/07/6456ea7999f3c.png)](https://bu.dusays.com/2023/05/07/6456ea7999f3c.png)\n\n\n\n### 2.基础原理\n\n\n\n#### CPU与寄存器\n\nCPU通过软件直接访问寄存器，直接写值，从而实现CPU操作引脚\n\n寄存器就是一种特殊存储器，以八个为一组来分组，相当于按钮，每个存储器下面都连着一根线，用以控制电路。\n\n寄存器通向引脚会经过驱动器，增大电流，之后连接至I/O端口\n\nCPU给寄存器写 `1`为高电平，此时LED两端皆为高电平，无法点亮\n\n给寄存器写`0`为低电平，两端互通，产生5V电压，LED点亮\n\n[![CPU操控原理.png](https://bu.dusays.com/2023/05/07/6456ea7887807.png)](https://bu.dusays.com/2023/05/07/6456ea7887807.png)\n\n#### 如何LED确定引脚\n\n[![点亮LED-原理-为什么P2_0是第一个LED灯.png](https://bu.dusays.com/2023/05/07/6456ea79d66ac.png)](https://bu.dusays.com/2023/05/07/6456ea79d66ac.png)\n\n图中`D1`LED灯为点亮目标，根据原理图可以看到其受`P20`引脚控制，在软件中其为`P2_0`变量，不同的电子元件有不同的控制引脚，具体操控引脚在原理图中查看。\n\n\n\n\n\n### 3.程序编写\n\n在程序中，对串口应用应使用十六进制进行赋值，在赋值时应添加十六进制标识符，即`0x--`，**且右位是低位**，如点亮第一个LED灯，应为`P2`串口赋值`1111 1110(B)`,转成十六进制为`0xFE(H)`\n\n下列为示例代码\n\n\n\n```c\n#include <REGX52.H>\n//添加51单片机程序的头文件，使程序可以为串口赋值\n\nvoid main()\n{\n    //'0x'代表声明是十六位进制，'FE'则对应的是 '1111 1110',遵守右位是低位\n    P2 = 0xFE;\n    \n}\n```\n\n\n\n[![二进制转十六进制对照表.png](https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png)](https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png)\n\n\n\n\n\n### 4.编译与下载\n\n\n\n#### 编译\n\n1. 点击控件栏第一个控件(见图中箭头所指)\n\n2. 弹出窗口后，选择`OutPut`栏\n\n3. 勾选`create HEX File`项，即可生成编译后的单片机可执行文件\n\n   ###### 每一个项目都要重复此步骤\n\n[![程序编译与烧录-2.png](https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png)](https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png)\n\n\n\n#### 下载\n\n1. 打开STC-ISP软件\n\n2. 将单片机连接至电脑\n\n3. 选择单片机型号`STC89C52`型号\n\n4. 点击''打开程序文件''，选择Keil5项目保存的路径，打开对应项目的`Objects`文件夹，选择里面的`.hex`后缀名文件\n\n   ###### 如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\n\n   \n\n[![程序编译与烧录.png](https://bu.dusays.com/2023/05/07/6456ea7a65186.png)](https://bu.dusays.com/2023/05/07/6456ea7a65186.png)\n\n完成后点击\"下载\"，随后重启单片机，即可看到烧录成功，程序开始运转\n\n\n\n\n\n------\n\n\n\n## 1-2 LED闪烁\n\n### 1.程序逻辑\n\n##### 程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\n\n\n\n##### 编写逻辑\n\n- 需要编写一个重复空运行500ms，不执行任何操作的延时函数\n- 需要一个死循环，其内部执行:点亮第一个LED -> 延时500ms -> 熄灭第一个LED -> 延时500ms\n\n\n\n### 2.程序编写\n\n#### 创建工程\n\n创建工程请参考`1-1点亮LED`的教程\n\n#### 编写代码\n\n###### 延时函数\n\n首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的**软件延时计算器**来生成函数\n\n食用方法\n\n1. 设定系统频率，江科大使用的晶振频率是`12MHz`，目前各大购物平台出售的开发板更多使用`11.0592MHz`，具体数据请询问店家或自行查看晶振上的参数。\n2. 设置定时长度，注意单位是毫秒还是秒\n3. 8051指令集选择`STC-Y1`,此指令集适用于`STC89Cxx/STC89LExx/STC90Cxx/STC90LExx`系列\n4. 设定好参数后，点击`生成C代码`,将其复制到程序中\n\n[![延时函数教程.png](https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png)](https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png)\n\n###### 完整代码\n\n```c\n#include <REGX52.H>\n//添加51单片机程序的头文件，使程序可以为串口赋值\n#include <INTRINS.H>\n//此为延时函数运行所需要的头文件\n\nvoid Delay500ms()//延时函数，通过重复空运行实现 \n{\n    unsigned char i,j,k;\n    _hop_();\n    i = 4;\n    j = 129;\n    k = 119;\n    do\n    {\n       do\n       {\n           while(--k);\n       }while(--j);\n    }while(--i);\n}\n\nvoid main()\n{\n    while(1)//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环\n    {\n    \tP2 = 0xFE;//点亮第一个LED\n        Delay500ms();//调用延时函数\n        P2 = 0xFF;//全部熄灭\n        Delay500ms();//调用延时函数\n        \n    }\n}\n```\n\n\n\n\n\n#### 编译下载\n\n请参考`1-1点亮LED`中的`4.编译与下载`文章，切记编译时要点击勾选工具栏中的`create HEX File`项，以生成可执行文件\n\n\n\n------\n\n\n\n## 1-3 LED流水灯\n\n\n\n### 1.程序逻辑\n\n##### 程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\n\n##### 编写逻辑\n\n- 需要编写一个重复空运行1ms，不执行任何操作的延时函数，形参列表可以接受无符号整型，延时时间受形参列表控制\n- 需要一个死循环，其内部执行:点亮第一个LED -> 延时设定时间 -> 点亮第二个LED -> 延时设定时间->············直到第八个，重复此过程\n\n\n\n### 2.程序编写\n\n#### 创建工程\n\n创建工程请参考`1-1点亮LED`的教程\n\n\n\n#### 编写代码\n\n###### 延时函数\n\n首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的**软件延时计算器**来生成函数\n\n食用方法\n\n1. 设定系统频率，江科大使用的晶振频率是`12MHz`，目前各大购物平台出售的开发板更多使用`11.0592MHz`，具体数据请询问店家或自行查看晶振上的参数。\n2. 设置定时长度，注意单位是毫秒还是秒\n3. 8051指令集选择`STC-Y1`,此指令集适用于`STC89Cxx/STC89LExx/STC90Cxx/STC90LExx`系列\n4. 设定好参数后，点击`生成C代码`,**将其复制到程序中**\n\n\n\n###### 完整代码\n\n```c\n#include <REGX52.H>\n//添加51单片机程序的头文件，使程序可以为串口赋值\n#include <INTRINS.H>\n//此为延时函数运行所需要的头文件\n\nvoid Delay1ms(unsigned int xms)//延时函数，通过重复空运行实现 \n{\n    unsigned char i,j;\n   \n    while(xms)\n    {\n      i = 2;\n      j = 239;\n     do\n        {\n           while(--j);\n        }while(--i);\n        xms--;\n    }\n}\n\nvoid main()\n{\n    while(1)//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环\n    {\n    \tP2 = 0xFE;\n        Delay1ms(123);\n        P2 = 0xFD;\n        Delay1ms(213);\n        P2 = 0xFB;\n        Delay1ms(312);\n        P2 = 0xF7;\n        Delay1ms(234);\n        P2 = 0xEF;\n        Delay1ms(432);\n        P2 = 0xDF;\n        Delay1ms(345);\n        P2 = 0xBF;\n        Delay1ms(645);\n        P2 = 0x7F;\n        Delay1ms(234);\n        \n    }\n}\n```\n\n#### 编译下载\n\n请参考`1-1点亮LED`中的`4.编译与下载`文章，切记编译时要点击勾选工具栏中的`create HEX File`项，以生成可执行文件\n\n\n\n------\n\n\n\n# 基础知识\n\n- VCC是正极，GND是负极\n- LED的图标为下图，在作为图标时，左正右负；实物LED查看内电极用于分辨，较小的电极为正电极，较大的为负电极。\n\n[![发光二极管.png](https://bu.dusays.com/2023/05/07/6456ea78a1c37.png)](https://bu.dusays.com/2023/05/07/6456ea78a1c37.png)g)\n\n- 电阻102=1K，10为有效数据，2为倍率；例如473即为47 000 = 47K；例如1001 = 100 0 = 1K。也就是说：共有三位时，前二位正常抄，第三位是几就在前两位后加几个零；共有四位时，前三位照抄，第四位是几就加几个零。\n- 单片机中，引脚实际输出时5V(高电平)或0V(低电平)，便于理解，可以理解为输出的是 + 或 -.\n- 高低电平在单片机中使用的是\"TTL电平\"(一种协议规范，相当于规定+是5V，-是0V)\n\n  ","source":"_posts/笔记：51单片机.md","raw":"---\ntitle: 笔记：51单片机\n---\n\n# 51单片机笔记\n\n\n\n# 软件准备\n\n\n\n## Keil5\n\n用于单片机的源码编写和编译，去官网下载注意使用C51版本\n\n\n\n####  1.官网下载\n\n前往 Https://www.keil.com 下载\n\n####  2.白嫖资料包\n\n江科大的资料包\n\n百度网盘:https://pan.baidu.com/share/init?surl=vDTN2o8ffvczzNQGfyjHng\n\n密码:gdzff\n\n###### 注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\n\n在安装后，打开目录找到`TOOLS.INI `找到PATH项，修改路径为安装路径\n\n#### 3.Keil5的破解\n\n##### 1.在安装包中打开KEIL_LIC破解程序运行\n\n[![Keil破解教程-1.png](https://bu.dusays.com/2023/05/07/6456ea7893efc.png)](https://bu.dusays.com/2023/05/07/6456ea7893efc.png)\n\n##### 2.将Keil5以管理员身份运行\n\n##### 3.打开后点击Feil中的License Management项，查看License Management窗口右上角的computer ID中的CID，将其复制\n\n##### 4.在KEIL_LIC的CID栏粘贴后点击下方Generate\n\n[![Keil破解教程-2.png](https://bu.dusays.com/2023/05/07/6456eb972a253.png)](https://bu.dusays.com/2023/05/07/6456eb972a253.png)\n\n#### 5.复制到Keil5的LIC，点击Add LIC，完成破解\n\n\n\n------\n\n\n\n\n\n## STC-ISP烧录软件与USB驱动\n\n### STC-ISP软件\n\n在资料包中，STC-ISP可直接复制至桌面\n\n### USB驱动\n\n打开“stc-isp\\USB to UART Driver\\CH340_CH341”文件夹，双击运行ch341ser.exe程序，默认安装即可，等待“驱动安装成功”窗口弹出即可\n\n###### 在C盘可以找到\"WCH.CN文件夹“即为安装成功\n\n\n\n\n\n------\n\n\n\n\n\n# 单片机介绍\n\n\n\n### 单片机定义\n\n- 单片机，英文“Micro Controller Unit“,简称MCU\n\n- 内部集成了CPU、RAM、ROM、定时器、终端系统、通讯接口等一系列电脑的常用硬件功能\n- 单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如点击，LED等）的控制\n- 单片机和计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，也是了解计算机原理与结构的最佳选择\n\n\n\n### STC89C52RC单片机参数\n\n淘宝普遍使用的是普中科技的开发板，芯片是带RC结尾，与江科大的公开课使用的开发板略有差异，并无过大差异\n\n- 所属系列：51单片机系列\n- 公司：STC公司\n- 位数：8位\n- RAM：512字节\n- ROM：8K（Flash）\n- 工作频率：11.0592MHz（晶振频率）\n\n\n\n### 51单片机名称的由来\n\n51单片机是指使用80年代Intel开发的8051单片机内核的统称。\n\n也指对所有兼容Intel 8031指令系统的单片机的统称。\n\n\n\n### 命名规则\n\n[![STC89C52命名规则.png](https://bu.dusays.com/2023/05/07/6456ea789e436.png)](https://bu.dusays.com/2023/05/07/6456ea789e436.png)\n\n------\n\n\n\n# 练习工程\n\n\n\n## 1-1 点亮LED\n\n\n\n### 1.创建工程\n\n运行Keil5后，在上侧工具栏中点击`Project`中的`New μVision Project`项，自选一个文件位置存放项目，同样要手动创建新的文件夹。\n\n创建后会跳出选择CPU的窗口，选择`AT89C52`（不同公司的生产，但是具体参数一样）\n\n[![点亮LED-创建工程-1.png](https://bu.dusays.com/2023/05/07/6456ea788df6b.png)](https://bu.dusays.com/2023/05/07/6456ea788df6b.png)\n\n创建后应当弹出本窗口，未弹出应当检查`TOOLS.INI`配置文件中的`PATH`项是否更改为正确的程序路径\n\n 创建成功后在侧边栏按照下列路径右键`Source Group 1`\n\n[![点亮LED-创建工程-2.png](https://bu.dusays.com/2023/05/07/6456ea789f80c.png)](https://bu.dusays.com/2023/05/07/6456ea789f80c.png)\n\n选择`Add New Item to Group 'Source Group1'`\n\n[![点亮LED-创建工程-3.png](https://bu.dusays.com/2023/05/07/6456ea797f18b.png)](https://bu.dusays.com/2023/05/07/6456ea797f18b.png)\n\n在下面选择\"C File(. c)\"文件(可用不同语言，本笔记使用的语言是C)-`name`填写`main`\n\n[![点亮LED-创建工程-4.png](https://bu.dusays.com/2023/05/07/6456ea7999f3c.png)](https://bu.dusays.com/2023/05/07/6456ea7999f3c.png)\n\n\n\n### 2.基础原理\n\n\n\n#### CPU与寄存器\n\nCPU通过软件直接访问寄存器，直接写值，从而实现CPU操作引脚\n\n寄存器就是一种特殊存储器，以八个为一组来分组，相当于按钮，每个存储器下面都连着一根线，用以控制电路。\n\n寄存器通向引脚会经过驱动器，增大电流，之后连接至I/O端口\n\nCPU给寄存器写 `1`为高电平，此时LED两端皆为高电平，无法点亮\n\n给寄存器写`0`为低电平，两端互通，产生5V电压，LED点亮\n\n[![CPU操控原理.png](https://bu.dusays.com/2023/05/07/6456ea7887807.png)](https://bu.dusays.com/2023/05/07/6456ea7887807.png)\n\n#### 如何LED确定引脚\n\n[![点亮LED-原理-为什么P2_0是第一个LED灯.png](https://bu.dusays.com/2023/05/07/6456ea79d66ac.png)](https://bu.dusays.com/2023/05/07/6456ea79d66ac.png)\n\n图中`D1`LED灯为点亮目标，根据原理图可以看到其受`P20`引脚控制，在软件中其为`P2_0`变量，不同的电子元件有不同的控制引脚，具体操控引脚在原理图中查看。\n\n\n\n\n\n### 3.程序编写\n\n在程序中，对串口应用应使用十六进制进行赋值，在赋值时应添加十六进制标识符，即`0x--`，**且右位是低位**，如点亮第一个LED灯，应为`P2`串口赋值`1111 1110(B)`,转成十六进制为`0xFE(H)`\n\n下列为示例代码\n\n\n\n```c\n#include <REGX52.H>\n//添加51单片机程序的头文件，使程序可以为串口赋值\n\nvoid main()\n{\n    //'0x'代表声明是十六位进制，'FE'则对应的是 '1111 1110',遵守右位是低位\n    P2 = 0xFE;\n    \n}\n```\n\n\n\n[![二进制转十六进制对照表.png](https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png)](https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png)\n\n\n\n\n\n### 4.编译与下载\n\n\n\n#### 编译\n\n1. 点击控件栏第一个控件(见图中箭头所指)\n\n2. 弹出窗口后，选择`OutPut`栏\n\n3. 勾选`create HEX File`项，即可生成编译后的单片机可执行文件\n\n   ###### 每一个项目都要重复此步骤\n\n[![程序编译与烧录-2.png](https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png)](https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png)\n\n\n\n#### 下载\n\n1. 打开STC-ISP软件\n\n2. 将单片机连接至电脑\n\n3. 选择单片机型号`STC89C52`型号\n\n4. 点击''打开程序文件''，选择Keil5项目保存的路径，打开对应项目的`Objects`文件夹，选择里面的`.hex`后缀名文件\n\n   ###### 如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\n\n   \n\n[![程序编译与烧录.png](https://bu.dusays.com/2023/05/07/6456ea7a65186.png)](https://bu.dusays.com/2023/05/07/6456ea7a65186.png)\n\n完成后点击\"下载\"，随后重启单片机，即可看到烧录成功，程序开始运转\n\n\n\n\n\n------\n\n\n\n## 1-2 LED闪烁\n\n### 1.程序逻辑\n\n##### 程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\n\n\n\n##### 编写逻辑\n\n- 需要编写一个重复空运行500ms，不执行任何操作的延时函数\n- 需要一个死循环，其内部执行:点亮第一个LED -> 延时500ms -> 熄灭第一个LED -> 延时500ms\n\n\n\n### 2.程序编写\n\n#### 创建工程\n\n创建工程请参考`1-1点亮LED`的教程\n\n#### 编写代码\n\n###### 延时函数\n\n首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的**软件延时计算器**来生成函数\n\n食用方法\n\n1. 设定系统频率，江科大使用的晶振频率是`12MHz`，目前各大购物平台出售的开发板更多使用`11.0592MHz`，具体数据请询问店家或自行查看晶振上的参数。\n2. 设置定时长度，注意单位是毫秒还是秒\n3. 8051指令集选择`STC-Y1`,此指令集适用于`STC89Cxx/STC89LExx/STC90Cxx/STC90LExx`系列\n4. 设定好参数后，点击`生成C代码`,将其复制到程序中\n\n[![延时函数教程.png](https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png)](https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png)\n\n###### 完整代码\n\n```c\n#include <REGX52.H>\n//添加51单片机程序的头文件，使程序可以为串口赋值\n#include <INTRINS.H>\n//此为延时函数运行所需要的头文件\n\nvoid Delay500ms()//延时函数，通过重复空运行实现 \n{\n    unsigned char i,j,k;\n    _hop_();\n    i = 4;\n    j = 129;\n    k = 119;\n    do\n    {\n       do\n       {\n           while(--k);\n       }while(--j);\n    }while(--i);\n}\n\nvoid main()\n{\n    while(1)//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环\n    {\n    \tP2 = 0xFE;//点亮第一个LED\n        Delay500ms();//调用延时函数\n        P2 = 0xFF;//全部熄灭\n        Delay500ms();//调用延时函数\n        \n    }\n}\n```\n\n\n\n\n\n#### 编译下载\n\n请参考`1-1点亮LED`中的`4.编译与下载`文章，切记编译时要点击勾选工具栏中的`create HEX File`项，以生成可执行文件\n\n\n\n------\n\n\n\n## 1-3 LED流水灯\n\n\n\n### 1.程序逻辑\n\n##### 程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\n\n##### 编写逻辑\n\n- 需要编写一个重复空运行1ms，不执行任何操作的延时函数，形参列表可以接受无符号整型，延时时间受形参列表控制\n- 需要一个死循环，其内部执行:点亮第一个LED -> 延时设定时间 -> 点亮第二个LED -> 延时设定时间->············直到第八个，重复此过程\n\n\n\n### 2.程序编写\n\n#### 创建工程\n\n创建工程请参考`1-1点亮LED`的教程\n\n\n\n#### 编写代码\n\n###### 延时函数\n\n首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的**软件延时计算器**来生成函数\n\n食用方法\n\n1. 设定系统频率，江科大使用的晶振频率是`12MHz`，目前各大购物平台出售的开发板更多使用`11.0592MHz`，具体数据请询问店家或自行查看晶振上的参数。\n2. 设置定时长度，注意单位是毫秒还是秒\n3. 8051指令集选择`STC-Y1`,此指令集适用于`STC89Cxx/STC89LExx/STC90Cxx/STC90LExx`系列\n4. 设定好参数后，点击`生成C代码`,**将其复制到程序中**\n\n\n\n###### 完整代码\n\n```c\n#include <REGX52.H>\n//添加51单片机程序的头文件，使程序可以为串口赋值\n#include <INTRINS.H>\n//此为延时函数运行所需要的头文件\n\nvoid Delay1ms(unsigned int xms)//延时函数，通过重复空运行实现 \n{\n    unsigned char i,j;\n   \n    while(xms)\n    {\n      i = 2;\n      j = 239;\n     do\n        {\n           while(--j);\n        }while(--i);\n        xms--;\n    }\n}\n\nvoid main()\n{\n    while(1)//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环\n    {\n    \tP2 = 0xFE;\n        Delay1ms(123);\n        P2 = 0xFD;\n        Delay1ms(213);\n        P2 = 0xFB;\n        Delay1ms(312);\n        P2 = 0xF7;\n        Delay1ms(234);\n        P2 = 0xEF;\n        Delay1ms(432);\n        P2 = 0xDF;\n        Delay1ms(345);\n        P2 = 0xBF;\n        Delay1ms(645);\n        P2 = 0x7F;\n        Delay1ms(234);\n        \n    }\n}\n```\n\n#### 编译下载\n\n请参考`1-1点亮LED`中的`4.编译与下载`文章，切记编译时要点击勾选工具栏中的`create HEX File`项，以生成可执行文件\n\n\n\n------\n\n\n\n# 基础知识\n\n- VCC是正极，GND是负极\n- LED的图标为下图，在作为图标时，左正右负；实物LED查看内电极用于分辨，较小的电极为正电极，较大的为负电极。\n\n[![发光二极管.png](https://bu.dusays.com/2023/05/07/6456ea78a1c37.png)](https://bu.dusays.com/2023/05/07/6456ea78a1c37.png)g)\n\n- 电阻102=1K，10为有效数据，2为倍率；例如473即为47 000 = 47K；例如1001 = 100 0 = 1K。也就是说：共有三位时，前二位正常抄，第三位是几就在前两位后加几个零；共有四位时，前三位照抄，第四位是几就加几个零。\n- 单片机中，引脚实际输出时5V(高电平)或0V(低电平)，便于理解，可以理解为输出的是 + 或 -.\n- 高低电平在单片机中使用的是\"TTL电平\"(一种协议规范，相当于规定+是5V，-是0V)\n\n  ","slug":"笔记：51单片机","published":1,"date":"2023-12-09T10:24:12.689Z","updated":"2023-05-07T00:51:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpxwwhz40003lc4dc16q53oo","content":"<h1 id=\"51单片机笔记\"><a href=\"#51单片机笔记\" class=\"headerlink\" title=\"51单片机笔记\"></a>51单片机笔记</h1><h1 id=\"软件准备\"><a href=\"#软件准备\" class=\"headerlink\" title=\"软件准备\"></a>软件准备</h1><h2 id=\"Keil5\"><a href=\"#Keil5\" class=\"headerlink\" title=\"Keil5\"></a>Keil5</h2><p>用于单片机的源码编写和编译，去官网下载注意使用C51版本</p>\n<h4 id=\"1-官网下载\"><a href=\"#1-官网下载\" class=\"headerlink\" title=\"1.官网下载\"></a>1.官网下载</h4><p>前往 Https://<a href=\"http://www.keil.com/\">www.keil.com</a> 下载</p>\n<h4 id=\"2-白嫖资料包\"><a href=\"#2-白嫖资料包\" class=\"headerlink\" title=\"2.白嫖资料包\"></a>2.白嫖资料包</h4><p>江科大的资料包</p>\n<p>百度网盘:<a href=\"https://pan.baidu.com/share/init?surl=vDTN2o8ffvczzNQGfyjHng\">https://pan.baidu.com/share/init?surl=vDTN2o8ffvczzNQGfyjHng</a></p>\n<p>密码:gdzff</p>\n<h6 id=\"注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\"><a href=\"#注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\" class=\"headerlink\" title=\"注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\"></a>注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。</h6><p>在安装后，打开目录找到<code>TOOLS.INI </code>找到PATH项，修改路径为安装路径</p>\n<h4 id=\"3-Keil5的破解\"><a href=\"#3-Keil5的破解\" class=\"headerlink\" title=\"3.Keil5的破解\"></a>3.Keil5的破解</h4><h5 id=\"1-在安装包中打开KEIL-LIC破解程序运行\"><a href=\"#1-在安装包中打开KEIL-LIC破解程序运行\" class=\"headerlink\" title=\"1.在安装包中打开KEIL_LIC破解程序运行\"></a>1.在安装包中打开KEIL_LIC破解程序运行</h5><p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7893efc.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7893efc.png\" alt=\"Keil破解教程-1.png\"></a></p>\n<h5 id=\"2-将Keil5以管理员身份运行\"><a href=\"#2-将Keil5以管理员身份运行\" class=\"headerlink\" title=\"2.将Keil5以管理员身份运行\"></a>2.将Keil5以管理员身份运行</h5><h5 id=\"3-打开后点击Feil中的License-Management项，查看License-Management窗口右上角的computer-ID中的CID，将其复制\"><a href=\"#3-打开后点击Feil中的License-Management项，查看License-Management窗口右上角的computer-ID中的CID，将其复制\" class=\"headerlink\" title=\"3.打开后点击Feil中的License Management项，查看License Management窗口右上角的computer ID中的CID，将其复制\"></a>3.打开后点击Feil中的License Management项，查看License Management窗口右上角的computer ID中的CID，将其复制</h5><h5 id=\"4-在KEIL-LIC的CID栏粘贴后点击下方Generate\"><a href=\"#4-在KEIL-LIC的CID栏粘贴后点击下方Generate\" class=\"headerlink\" title=\"4.在KEIL_LIC的CID栏粘贴后点击下方Generate\"></a>4.在KEIL_LIC的CID栏粘贴后点击下方Generate</h5><p><a href=\"https://bu.dusays.com/2023/05/07/6456eb972a253.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456eb972a253.png\" alt=\"Keil破解教程-2.png\"></a></p>\n<h4 id=\"5-复制到Keil5的LIC，点击Add-LIC，完成破解\"><a href=\"#5-复制到Keil5的LIC，点击Add-LIC，完成破解\" class=\"headerlink\" title=\"5.复制到Keil5的LIC，点击Add LIC，完成破解\"></a>5.复制到Keil5的LIC，点击Add LIC，完成破解</h4><hr>\n<h2 id=\"STC-ISP烧录软件与USB驱动\"><a href=\"#STC-ISP烧录软件与USB驱动\" class=\"headerlink\" title=\"STC-ISP烧录软件与USB驱动\"></a>STC-ISP烧录软件与USB驱动</h2><h3 id=\"STC-ISP软件\"><a href=\"#STC-ISP软件\" class=\"headerlink\" title=\"STC-ISP软件\"></a>STC-ISP软件</h3><p>在资料包中，STC-ISP可直接复制至桌面</p>\n<h3 id=\"USB驱动\"><a href=\"#USB驱动\" class=\"headerlink\" title=\"USB驱动\"></a>USB驱动</h3><p>打开“stc-isp\\USB to UART Driver\\CH340_CH341”文件夹，双击运行ch341ser.exe程序，默认安装即可，等待“驱动安装成功”窗口弹出即可</p>\n<h6 id=\"在C盘可以找到”WCH-CN文件夹“即为安装成功\"><a href=\"#在C盘可以找到”WCH-CN文件夹“即为安装成功\" class=\"headerlink\" title=\"在C盘可以找到”WCH.CN文件夹“即为安装成功\"></a>在C盘可以找到”WCH.CN文件夹“即为安装成功</h6><hr>\n<h1 id=\"单片机介绍\"><a href=\"#单片机介绍\" class=\"headerlink\" title=\"单片机介绍\"></a>单片机介绍</h1><h3 id=\"单片机定义\"><a href=\"#单片机定义\" class=\"headerlink\" title=\"单片机定义\"></a>单片机定义</h3><ul>\n<li><p>单片机，英文“Micro Controller Unit“,简称MCU</p>\n</li>\n<li><p>内部集成了CPU、RAM、ROM、定时器、终端系统、通讯接口等一系列电脑的常用硬件功能</p>\n</li>\n<li><p>单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如点击，LED等）的控制</p>\n</li>\n<li><p>单片机和计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，也是了解计算机原理与结构的最佳选择</p>\n</li>\n</ul>\n<h3 id=\"STC89C52RC单片机参数\"><a href=\"#STC89C52RC单片机参数\" class=\"headerlink\" title=\"STC89C52RC单片机参数\"></a>STC89C52RC单片机参数</h3><p>淘宝普遍使用的是普中科技的开发板，芯片是带RC结尾，与江科大的公开课使用的开发板略有差异，并无过大差异</p>\n<ul>\n<li>所属系列：51单片机系列</li>\n<li>公司：STC公司</li>\n<li>位数：8位</li>\n<li>RAM：512字节</li>\n<li>ROM：8K（Flash）</li>\n<li>工作频率：11.0592MHz（晶振频率）</li>\n</ul>\n<h3 id=\"51单片机名称的由来\"><a href=\"#51单片机名称的由来\" class=\"headerlink\" title=\"51单片机名称的由来\"></a>51单片机名称的由来</h3><p>51单片机是指使用80年代Intel开发的8051单片机内核的统称。</p>\n<p>也指对所有兼容Intel 8031指令系统的单片机的统称。</p>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><p><a href=\"https://bu.dusays.com/2023/05/07/6456ea789e436.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea789e436.png\" alt=\"STC89C52命名规则.png\"></a></p>\n<hr>\n<h1 id=\"练习工程\"><a href=\"#练习工程\" class=\"headerlink\" title=\"练习工程\"></a>练习工程</h1><h2 id=\"1-1-点亮LED\"><a href=\"#1-1-点亮LED\" class=\"headerlink\" title=\"1-1 点亮LED\"></a>1-1 点亮LED</h2><h3 id=\"1-创建工程\"><a href=\"#1-创建工程\" class=\"headerlink\" title=\"1.创建工程\"></a>1.创建工程</h3><p>运行Keil5后，在上侧工具栏中点击<code>Project</code>中的<code>New μVision Project</code>项，自选一个文件位置存放项目，同样要手动创建新的文件夹。</p>\n<p>创建后会跳出选择CPU的窗口，选择<code>AT89C52</code>（不同公司的生产，但是具体参数一样）</p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea788df6b.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea788df6b.png\" alt=\"点亮LED-创建工程-1.png\"></a></p>\n<p>创建后应当弹出本窗口，未弹出应当检查<code>TOOLS.INI</code>配置文件中的<code>PATH</code>项是否更改为正确的程序路径</p>\n<p> 创建成功后在侧边栏按照下列路径右键<code>Source Group 1</code></p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea789f80c.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea789f80c.png\" alt=\"点亮LED-创建工程-2.png\"></a></p>\n<p>选择<code>Add New Item to Group &#39;Source Group1&#39;</code></p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea797f18b.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea797f18b.png\" alt=\"点亮LED-创建工程-3.png\"></a></p>\n<p>在下面选择”C File(. c)”文件(可用不同语言，本笔记使用的语言是C)-<code>name</code>填写<code>main</code></p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7999f3c.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7999f3c.png\" alt=\"点亮LED-创建工程-4.png\"></a></p>\n<h3 id=\"2-基础原理\"><a href=\"#2-基础原理\" class=\"headerlink\" title=\"2.基础原理\"></a>2.基础原理</h3><h4 id=\"CPU与寄存器\"><a href=\"#CPU与寄存器\" class=\"headerlink\" title=\"CPU与寄存器\"></a>CPU与寄存器</h4><p>CPU通过软件直接访问寄存器，直接写值，从而实现CPU操作引脚</p>\n<p>寄存器就是一种特殊存储器，以八个为一组来分组，相当于按钮，每个存储器下面都连着一根线，用以控制电路。</p>\n<p>寄存器通向引脚会经过驱动器，增大电流，之后连接至I/O端口</p>\n<p>CPU给寄存器写 <code>1</code>为高电平，此时LED两端皆为高电平，无法点亮</p>\n<p>给寄存器写<code>0</code>为低电平，两端互通，产生5V电压，LED点亮</p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7887807.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7887807.png\" alt=\"CPU操控原理.png\"></a></p>\n<h4 id=\"如何LED确定引脚\"><a href=\"#如何LED确定引脚\" class=\"headerlink\" title=\"如何LED确定引脚\"></a>如何LED确定引脚</h4><p><a href=\"https://bu.dusays.com/2023/05/07/6456ea79d66ac.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea79d66ac.png\" alt=\"点亮LED-原理-为什么P2_0是第一个LED灯.png\"></a></p>\n<p>图中<code>D1</code>LED灯为点亮目标，根据原理图可以看到其受<code>P20</code>引脚控制，在软件中其为<code>P2_0</code>变量，不同的电子元件有不同的控制引脚，具体操控引脚在原理图中查看。</p>\n<h3 id=\"3-程序编写\"><a href=\"#3-程序编写\" class=\"headerlink\" title=\"3.程序编写\"></a>3.程序编写</h3><p>在程序中，对串口应用应使用十六进制进行赋值，在赋值时应添加十六进制标识符，即<code>0x--</code>，<strong>且右位是低位</strong>，如点亮第一个LED灯，应为<code>P2</code>串口赋值<code>1111 1110(B)</code>,转成十六进制为<code>0xFE(H)</code></p>\n<p>下列为示例代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;REGX52.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//添加51单片机程序的头文件，使程序可以为串口赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//&#x27;0x&#x27;代表声明是十六位进制，&#x27;FE&#x27;则对应的是 &#x27;1111 1110&#x27;,遵守右位是低位</span></span><br><span class=\"line\">    P2 = <span class=\"number\">0xFE</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png\" alt=\"二进制转十六进制对照表.png\"></a></p>\n<h3 id=\"4-编译与下载\"><a href=\"#4-编译与下载\" class=\"headerlink\" title=\"4.编译与下载\"></a>4.编译与下载</h3><h4 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h4><ol>\n<li><p>点击控件栏第一个控件(见图中箭头所指)</p>\n</li>\n<li><p>弹出窗口后，选择<code>OutPut</code>栏</p>\n</li>\n<li><p>勾选<code>create HEX File</code>项，即可生成编译后的单片机可执行文件</p>\n<h6 id=\"每一个项目都要重复此步骤\"><a href=\"#每一个项目都要重复此步骤\" class=\"headerlink\" title=\"每一个项目都要重复此步骤\"></a>每一个项目都要重复此步骤</h6></li>\n</ol>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png\" alt=\"程序编译与烧录-2.png\"></a></p>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ol>\n<li><p>打开STC-ISP软件</p>\n</li>\n<li><p>将单片机连接至电脑</p>\n</li>\n<li><p>选择单片机型号<code>STC89C52</code>型号</p>\n</li>\n<li><p>点击’’打开程序文件’’，选择Keil5项目保存的路径，打开对应项目的<code>Objects</code>文件夹，选择里面的<code>.hex</code>后缀名文件</p>\n<h6 id=\"如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\"><a href=\"#如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\" class=\"headerlink\" title=\"如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\"></a>如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看</h6></li>\n</ol>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7a65186.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7a65186.png\" alt=\"程序编译与烧录.png\"></a></p>\n<p>完成后点击”下载”，随后重启单片机，即可看到烧录成功，程序开始运转</p>\n<hr>\n<h2 id=\"1-2-LED闪烁\"><a href=\"#1-2-LED闪烁\" class=\"headerlink\" title=\"1-2 LED闪烁\"></a>1-2 LED闪烁</h2><h3 id=\"1-程序逻辑\"><a href=\"#1-程序逻辑\" class=\"headerlink\" title=\"1.程序逻辑\"></a>1.程序逻辑</h3><h5 id=\"程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\"><a href=\"#程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\" class=\"headerlink\" title=\"程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\"></a>程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁</h5><h5 id=\"编写逻辑\"><a href=\"#编写逻辑\" class=\"headerlink\" title=\"编写逻辑\"></a>编写逻辑</h5><ul>\n<li>需要编写一个重复空运行500ms，不执行任何操作的延时函数</li>\n<li>需要一个死循环，其内部执行:点亮第一个LED -&gt; 延时500ms -&gt; 熄灭第一个LED -&gt; 延时500ms</li>\n</ul>\n<h3 id=\"2-程序编写\"><a href=\"#2-程序编写\" class=\"headerlink\" title=\"2.程序编写\"></a>2.程序编写</h3><h4 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h4><p>创建工程请参考<code>1-1点亮LED</code>的教程</p>\n<h4 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><h6 id=\"延时函数\"><a href=\"#延时函数\" class=\"headerlink\" title=\"延时函数\"></a>延时函数</h6><p>首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的<strong>软件延时计算器</strong>来生成函数</p>\n<p>食用方法</p>\n<ol>\n<li>设定系统频率，江科大使用的晶振频率是<code>12MHz</code>，目前各大购物平台出售的开发板更多使用<code>11.0592MHz</code>，具体数据请询问店家或自行查看晶振上的参数。</li>\n<li>设置定时长度，注意单位是毫秒还是秒</li>\n<li>8051指令集选择<code>STC-Y1</code>,此指令集适用于<code>STC89Cxx/STC89LExx/STC90Cxx/STC90LExx</code>系列</li>\n<li>设定好参数后，点击<code>生成C代码</code>,将其复制到程序中</li>\n</ol>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png\" alt=\"延时函数教程.png\"></a></p>\n<h6 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;REGX52.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//添加51单片机程序的头文件，使程序可以为串口赋值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;INTRINS.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//此为延时函数运行所需要的头文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay500ms</span><span class=\"params\">()</span><span class=\"comment\">//延时函数，通过重复空运行实现 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> i,j,k;</span><br><span class=\"line\">    _hop_();</span><br><span class=\"line\">    i = <span class=\"number\">4</span>;</span><br><span class=\"line\">    j = <span class=\"number\">129</span>;</span><br><span class=\"line\">    k = <span class=\"number\">119</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"keyword\">do</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">while</span>(--k);</span><br><span class=\"line\">       &#125;<span class=\"keyword\">while</span>(--j);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(--i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)<span class=\"comment\">//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tP2 = <span class=\"number\">0xFE</span>;<span class=\"comment\">//点亮第一个LED</span></span><br><span class=\"line\">        Delay500ms();<span class=\"comment\">//调用延时函数</span></span><br><span class=\"line\">        P2 = <span class=\"number\">0xFF</span>;<span class=\"comment\">//全部熄灭</span></span><br><span class=\"line\">        Delay500ms();<span class=\"comment\">//调用延时函数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"编译下载\"><a href=\"#编译下载\" class=\"headerlink\" title=\"编译下载\"></a>编译下载</h4><p>请参考<code>1-1点亮LED</code>中的<code>4.编译与下载</code>文章，切记编译时要点击勾选工具栏中的<code>create HEX File</code>项，以生成可执行文件</p>\n<hr>\n<h2 id=\"1-3-LED流水灯\"><a href=\"#1-3-LED流水灯\" class=\"headerlink\" title=\"1-3 LED流水灯\"></a>1-3 LED流水灯</h2><h3 id=\"1-程序逻辑-1\"><a href=\"#1-程序逻辑-1\" class=\"headerlink\" title=\"1.程序逻辑\"></a>1.程序逻辑</h3><h5 id=\"程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\"><a href=\"#程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\" class=\"headerlink\" title=\"程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\"></a>程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。</h5><h5 id=\"编写逻辑-1\"><a href=\"#编写逻辑-1\" class=\"headerlink\" title=\"编写逻辑\"></a>编写逻辑</h5><ul>\n<li>需要编写一个重复空运行1ms，不执行任何操作的延时函数，形参列表可以接受无符号整型，延时时间受形参列表控制</li>\n<li>需要一个死循环，其内部执行:点亮第一个LED -&gt; 延时设定时间 -&gt; 点亮第二个LED -&gt; 延时设定时间-&gt;············直到第八个，重复此过程</li>\n</ul>\n<h3 id=\"2-程序编写-1\"><a href=\"#2-程序编写-1\" class=\"headerlink\" title=\"2.程序编写\"></a>2.程序编写</h3><h4 id=\"创建工程-1\"><a href=\"#创建工程-1\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h4><p>创建工程请参考<code>1-1点亮LED</code>的教程</p>\n<h4 id=\"编写代码-1\"><a href=\"#编写代码-1\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><h6 id=\"延时函数-1\"><a href=\"#延时函数-1\" class=\"headerlink\" title=\"延时函数\"></a>延时函数</h6><p>首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的<strong>软件延时计算器</strong>来生成函数</p>\n<p>食用方法</p>\n<ol>\n<li>设定系统频率，江科大使用的晶振频率是<code>12MHz</code>，目前各大购物平台出售的开发板更多使用<code>11.0592MHz</code>，具体数据请询问店家或自行查看晶振上的参数。</li>\n<li>设置定时长度，注意单位是毫秒还是秒</li>\n<li>8051指令集选择<code>STC-Y1</code>,此指令集适用于<code>STC89Cxx/STC89LExx/STC90Cxx/STC90LExx</code>系列</li>\n<li>设定好参数后，点击<code>生成C代码</code>,<strong>将其复制到程序中</strong></li>\n</ol>\n<h6 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;REGX52.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//添加51单片机程序的头文件，使程序可以为串口赋值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;INTRINS.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//此为延时函数运行所需要的头文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay1ms</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> xms)</span><span class=\"comment\">//延时函数，通过重复空运行实现 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> i,j;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(xms)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      i = <span class=\"number\">2</span>;</span><br><span class=\"line\">      j = <span class=\"number\">239</span>;</span><br><span class=\"line\">     <span class=\"keyword\">do</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           <span class=\"keyword\">while</span>(--j);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(--i);</span><br><span class=\"line\">        xms--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)<span class=\"comment\">//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tP2 = <span class=\"number\">0xFE</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">123</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xFD</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">213</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xFB</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">312</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xF7</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">234</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xEF</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">432</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xDF</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">345</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xBF</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">645</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0x7F</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">234</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译下载-1\"><a href=\"#编译下载-1\" class=\"headerlink\" title=\"编译下载\"></a>编译下载</h4><p>请参考<code>1-1点亮LED</code>中的<code>4.编译与下载</code>文章，切记编译时要点击勾选工具栏中的<code>create HEX File</code>项，以生成可执行文件</p>\n<hr>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><ul>\n<li>VCC是正极，GND是负极</li>\n<li>LED的图标为下图，在作为图标时，左正右负；实物LED查看内电极用于分辨，较小的电极为正电极，较大的为负电极。</li>\n</ul>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea78a1c37.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea78a1c37.png\" alt=\"发光二极管.png\"></a>g)</p>\n<ul>\n<li>电阻102=1K，10为有效数据，2为倍率；例如473即为47 000 = 47K；例如1001 = 100 0 = 1K。也就是说：共有三位时，前二位正常抄，第三位是几就在前两位后加几个零；共有四位时，前三位照抄，第四位是几就加几个零。</li>\n<li>单片机中，引脚实际输出时5V(高电平)或0V(低电平)，便于理解，可以理解为输出的是 + 或 -.</li>\n<li>高低电平在单片机中使用的是”TTL电平”(一种协议规范，相当于规定+是5V，-是0V)</li>\n</ul>\n","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":"<h1 id=\"51单片机笔记\"><a href=\"#51单片机笔记\" class=\"headerlink\" title=\"51单片机笔记\"></a>51单片机笔记</h1><h1 id=\"软件准备\"><a href=\"#软件准备\" class=\"headerlink\" title=\"软件准备\"></a>软件准备</h1><h2 id=\"Keil5\"><a href=\"#Keil5\" class=\"headerlink\" title=\"Keil5\"></a>Keil5</h2><p>用于单片机的源码编写和编译，去官网下载注意使用C51版本</p>\n<h4 id=\"1-官网下载\"><a href=\"#1-官网下载\" class=\"headerlink\" title=\"1.官网下载\"></a>1.官网下载</h4><p>前往 Https://<a href=\"http://www.keil.com/\">www.keil.com</a> 下载</p>\n<h4 id=\"2-白嫖资料包\"><a href=\"#2-白嫖资料包\" class=\"headerlink\" title=\"2.白嫖资料包\"></a>2.白嫖资料包</h4><p>江科大的资料包</p>\n<p>百度网盘:<a href=\"https://pan.baidu.com/share/init?surl=vDTN2o8ffvczzNQGfyjHng\">https://pan.baidu.com/share/init?surl=vDTN2o8ffvczzNQGfyjHng</a></p>\n<p>密码:gdzff</p>\n<h6 id=\"注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\"><a href=\"#注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\" class=\"headerlink\" title=\"注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。\"></a>注意，这玩应安装的时候不会自己创建文件夹，不手动创建空文件夹，就会乱装。</h6><p>在安装后，打开目录找到<code>TOOLS.INI </code>找到PATH项，修改路径为安装路径</p>\n<h4 id=\"3-Keil5的破解\"><a href=\"#3-Keil5的破解\" class=\"headerlink\" title=\"3.Keil5的破解\"></a>3.Keil5的破解</h4><h5 id=\"1-在安装包中打开KEIL-LIC破解程序运行\"><a href=\"#1-在安装包中打开KEIL-LIC破解程序运行\" class=\"headerlink\" title=\"1.在安装包中打开KEIL_LIC破解程序运行\"></a>1.在安装包中打开KEIL_LIC破解程序运行</h5><p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7893efc.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7893efc.png\" alt=\"Keil破解教程-1.png\"></a></p>\n<h5 id=\"2-将Keil5以管理员身份运行\"><a href=\"#2-将Keil5以管理员身份运行\" class=\"headerlink\" title=\"2.将Keil5以管理员身份运行\"></a>2.将Keil5以管理员身份运行</h5><h5 id=\"3-打开后点击Feil中的License-Management项，查看License-Management窗口右上角的computer-ID中的CID，将其复制\"><a href=\"#3-打开后点击Feil中的License-Management项，查看License-Management窗口右上角的computer-ID中的CID，将其复制\" class=\"headerlink\" title=\"3.打开后点击Feil中的License Management项，查看License Management窗口右上角的computer ID中的CID，将其复制\"></a>3.打开后点击Feil中的License Management项，查看License Management窗口右上角的computer ID中的CID，将其复制</h5><h5 id=\"4-在KEIL-LIC的CID栏粘贴后点击下方Generate\"><a href=\"#4-在KEIL-LIC的CID栏粘贴后点击下方Generate\" class=\"headerlink\" title=\"4.在KEIL_LIC的CID栏粘贴后点击下方Generate\"></a>4.在KEIL_LIC的CID栏粘贴后点击下方Generate</h5><p><a href=\"https://bu.dusays.com/2023/05/07/6456eb972a253.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456eb972a253.png\" alt=\"Keil破解教程-2.png\"></a></p>\n<h4 id=\"5-复制到Keil5的LIC，点击Add-LIC，完成破解\"><a href=\"#5-复制到Keil5的LIC，点击Add-LIC，完成破解\" class=\"headerlink\" title=\"5.复制到Keil5的LIC，点击Add LIC，完成破解\"></a>5.复制到Keil5的LIC，点击Add LIC，完成破解</h4><hr>\n<h2 id=\"STC-ISP烧录软件与USB驱动\"><a href=\"#STC-ISP烧录软件与USB驱动\" class=\"headerlink\" title=\"STC-ISP烧录软件与USB驱动\"></a>STC-ISP烧录软件与USB驱动</h2><h3 id=\"STC-ISP软件\"><a href=\"#STC-ISP软件\" class=\"headerlink\" title=\"STC-ISP软件\"></a>STC-ISP软件</h3><p>在资料包中，STC-ISP可直接复制至桌面</p>\n<h3 id=\"USB驱动\"><a href=\"#USB驱动\" class=\"headerlink\" title=\"USB驱动\"></a>USB驱动</h3><p>打开“stc-isp\\USB to UART Driver\\CH340_CH341”文件夹，双击运行ch341ser.exe程序，默认安装即可，等待“驱动安装成功”窗口弹出即可</p>\n<h6 id=\"在C盘可以找到”WCH-CN文件夹“即为安装成功\"><a href=\"#在C盘可以找到”WCH-CN文件夹“即为安装成功\" class=\"headerlink\" title=\"在C盘可以找到”WCH.CN文件夹“即为安装成功\"></a>在C盘可以找到”WCH.CN文件夹“即为安装成功</h6><hr>\n<h1 id=\"单片机介绍\"><a href=\"#单片机介绍\" class=\"headerlink\" title=\"单片机介绍\"></a>单片机介绍</h1><h3 id=\"单片机定义\"><a href=\"#单片机定义\" class=\"headerlink\" title=\"单片机定义\"></a>单片机定义</h3><ul>\n<li><p>单片机，英文“Micro Controller Unit“,简称MCU</p>\n</li>\n<li><p>内部集成了CPU、RAM、ROM、定时器、终端系统、通讯接口等一系列电脑的常用硬件功能</p>\n</li>\n<li><p>单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如点击，LED等）的控制</p>\n</li>\n<li><p>单片机和计算机相比，单片机算是一个袖珍版计算机，一个芯片就能构成完整的计算机系统。但在性能上，与计算机相差甚远，但单片机成本低、体积小、结构简单，也是了解计算机原理与结构的最佳选择</p>\n</li>\n</ul>\n<h3 id=\"STC89C52RC单片机参数\"><a href=\"#STC89C52RC单片机参数\" class=\"headerlink\" title=\"STC89C52RC单片机参数\"></a>STC89C52RC单片机参数</h3><p>淘宝普遍使用的是普中科技的开发板，芯片是带RC结尾，与江科大的公开课使用的开发板略有差异，并无过大差异</p>\n<ul>\n<li>所属系列：51单片机系列</li>\n<li>公司：STC公司</li>\n<li>位数：8位</li>\n<li>RAM：512字节</li>\n<li>ROM：8K（Flash）</li>\n<li>工作频率：11.0592MHz（晶振频率）</li>\n</ul>\n<h3 id=\"51单片机名称的由来\"><a href=\"#51单片机名称的由来\" class=\"headerlink\" title=\"51单片机名称的由来\"></a>51单片机名称的由来</h3><p>51单片机是指使用80年代Intel开发的8051单片机内核的统称。</p>\n<p>也指对所有兼容Intel 8031指令系统的单片机的统称。</p>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><p><a href=\"https://bu.dusays.com/2023/05/07/6456ea789e436.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea789e436.png\" alt=\"STC89C52命名规则.png\"></a></p>\n<hr>\n<h1 id=\"练习工程\"><a href=\"#练习工程\" class=\"headerlink\" title=\"练习工程\"></a>练习工程</h1><h2 id=\"1-1-点亮LED\"><a href=\"#1-1-点亮LED\" class=\"headerlink\" title=\"1-1 点亮LED\"></a>1-1 点亮LED</h2><h3 id=\"1-创建工程\"><a href=\"#1-创建工程\" class=\"headerlink\" title=\"1.创建工程\"></a>1.创建工程</h3><p>运行Keil5后，在上侧工具栏中点击<code>Project</code>中的<code>New μVision Project</code>项，自选一个文件位置存放项目，同样要手动创建新的文件夹。</p>\n<p>创建后会跳出选择CPU的窗口，选择<code>AT89C52</code>（不同公司的生产，但是具体参数一样）</p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea788df6b.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea788df6b.png\" alt=\"点亮LED-创建工程-1.png\"></a></p>\n<p>创建后应当弹出本窗口，未弹出应当检查<code>TOOLS.INI</code>配置文件中的<code>PATH</code>项是否更改为正确的程序路径</p>\n<p> 创建成功后在侧边栏按照下列路径右键<code>Source Group 1</code></p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea789f80c.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea789f80c.png\" alt=\"点亮LED-创建工程-2.png\"></a></p>\n<p>选择<code>Add New Item to Group &#39;Source Group1&#39;</code></p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea797f18b.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea797f18b.png\" alt=\"点亮LED-创建工程-3.png\"></a></p>\n<p>在下面选择”C File(. c)”文件(可用不同语言，本笔记使用的语言是C)-<code>name</code>填写<code>main</code></p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7999f3c.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7999f3c.png\" alt=\"点亮LED-创建工程-4.png\"></a></p>\n<h3 id=\"2-基础原理\"><a href=\"#2-基础原理\" class=\"headerlink\" title=\"2.基础原理\"></a>2.基础原理</h3><h4 id=\"CPU与寄存器\"><a href=\"#CPU与寄存器\" class=\"headerlink\" title=\"CPU与寄存器\"></a>CPU与寄存器</h4><p>CPU通过软件直接访问寄存器，直接写值，从而实现CPU操作引脚</p>\n<p>寄存器就是一种特殊存储器，以八个为一组来分组，相当于按钮，每个存储器下面都连着一根线，用以控制电路。</p>\n<p>寄存器通向引脚会经过驱动器，增大电流，之后连接至I/O端口</p>\n<p>CPU给寄存器写 <code>1</code>为高电平，此时LED两端皆为高电平，无法点亮</p>\n<p>给寄存器写<code>0</code>为低电平，两端互通，产生5V电压，LED点亮</p>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7887807.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7887807.png\" alt=\"CPU操控原理.png\"></a></p>\n<h4 id=\"如何LED确定引脚\"><a href=\"#如何LED确定引脚\" class=\"headerlink\" title=\"如何LED确定引脚\"></a>如何LED确定引脚</h4><p><a href=\"https://bu.dusays.com/2023/05/07/6456ea79d66ac.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea79d66ac.png\" alt=\"点亮LED-原理-为什么P2_0是第一个LED灯.png\"></a></p>\n<p>图中<code>D1</code>LED灯为点亮目标，根据原理图可以看到其受<code>P20</code>引脚控制，在软件中其为<code>P2_0</code>变量，不同的电子元件有不同的控制引脚，具体操控引脚在原理图中查看。</p>\n<h3 id=\"3-程序编写\"><a href=\"#3-程序编写\" class=\"headerlink\" title=\"3.程序编写\"></a>3.程序编写</h3><p>在程序中，对串口应用应使用十六进制进行赋值，在赋值时应添加十六进制标识符，即<code>0x--</code>，<strong>且右位是低位</strong>，如点亮第一个LED灯，应为<code>P2</code>串口赋值<code>1111 1110(B)</code>,转成十六进制为<code>0xFE(H)</code></p>\n<p>下列为示例代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;REGX52.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//添加51单片机程序的头文件，使程序可以为串口赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//&#x27;0x&#x27;代表声明是十六位进制，&#x27;FE&#x27;则对应的是 &#x27;1111 1110&#x27;,遵守右位是低位</span></span><br><span class=\"line\">    P2 = <span class=\"number\">0xFE</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea78a1ef9.png\" alt=\"二进制转十六进制对照表.png\"></a></p>\n<h3 id=\"4-编译与下载\"><a href=\"#4-编译与下载\" class=\"headerlink\" title=\"4.编译与下载\"></a>4.编译与下载</h3><h4 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h4><ol>\n<li><p>点击控件栏第一个控件(见图中箭头所指)</p>\n</li>\n<li><p>弹出窗口后，选择<code>OutPut</code>栏</p>\n</li>\n<li><p>勾选<code>create HEX File</code>项，即可生成编译后的单片机可执行文件</p>\n<h6 id=\"每一个项目都要重复此步骤\"><a href=\"#每一个项目都要重复此步骤\" class=\"headerlink\" title=\"每一个项目都要重复此步骤\"></a>每一个项目都要重复此步骤</h6></li>\n</ol>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7a1d2fb.png\" alt=\"程序编译与烧录-2.png\"></a></p>\n<h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><ol>\n<li><p>打开STC-ISP软件</p>\n</li>\n<li><p>将单片机连接至电脑</p>\n</li>\n<li><p>选择单片机型号<code>STC89C52</code>型号</p>\n</li>\n<li><p>点击’’打开程序文件’’，选择Keil5项目保存的路径，打开对应项目的<code>Objects</code>文件夹，选择里面的<code>.hex</code>后缀名文件</p>\n<h6 id=\"如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\"><a href=\"#如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\" class=\"headerlink\" title=\"如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看\"></a>如果没有，请检查路径是否正确，是否在Keil5中设置编译生成文件，设置编译请向上翻看</h6></li>\n</ol>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea7a65186.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea7a65186.png\" alt=\"程序编译与烧录.png\"></a></p>\n<p>完成后点击”下载”，随后重启单片机，即可看到烧录成功，程序开始运转</p>\n<hr>\n<h2 id=\"1-2-LED闪烁\"><a href=\"#1-2-LED闪烁\" class=\"headerlink\" title=\"1-2 LED闪烁\"></a>1-2 LED闪烁</h2><h3 id=\"1-程序逻辑\"><a href=\"#1-程序逻辑\" class=\"headerlink\" title=\"1.程序逻辑\"></a>1.程序逻辑</h3><h5 id=\"程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\"><a href=\"#程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\" class=\"headerlink\" title=\"程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁\"></a>程序需求：使第一个LED灯以1s为周期，亮灭各500ms闪烁</h5><h5 id=\"编写逻辑\"><a href=\"#编写逻辑\" class=\"headerlink\" title=\"编写逻辑\"></a>编写逻辑</h5><ul>\n<li>需要编写一个重复空运行500ms，不执行任何操作的延时函数</li>\n<li>需要一个死循环，其内部执行:点亮第一个LED -&gt; 延时500ms -&gt; 熄灭第一个LED -&gt; 延时500ms</li>\n</ul>\n<h3 id=\"2-程序编写\"><a href=\"#2-程序编写\" class=\"headerlink\" title=\"2.程序编写\"></a>2.程序编写</h3><h4 id=\"创建工程\"><a href=\"#创建工程\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h4><p>创建工程请参考<code>1-1点亮LED</code>的教程</p>\n<h4 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><h6 id=\"延时函数\"><a href=\"#延时函数\" class=\"headerlink\" title=\"延时函数\"></a>延时函数</h6><p>首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的<strong>软件延时计算器</strong>来生成函数</p>\n<p>食用方法</p>\n<ol>\n<li>设定系统频率，江科大使用的晶振频率是<code>12MHz</code>，目前各大购物平台出售的开发板更多使用<code>11.0592MHz</code>，具体数据请询问店家或自行查看晶振上的参数。</li>\n<li>设置定时长度，注意单位是毫秒还是秒</li>\n<li>8051指令集选择<code>STC-Y1</code>,此指令集适用于<code>STC89Cxx/STC89LExx/STC90Cxx/STC90LExx</code>系列</li>\n<li>设定好参数后，点击<code>生成C代码</code>,将其复制到程序中</li>\n</ol>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea78ac0f4.png\" alt=\"延时函数教程.png\"></a></p>\n<h6 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;REGX52.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//添加51单片机程序的头文件，使程序可以为串口赋值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;INTRINS.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//此为延时函数运行所需要的头文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay500ms</span><span class=\"params\">()</span><span class=\"comment\">//延时函数，通过重复空运行实现 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> i,j,k;</span><br><span class=\"line\">    _hop_();</span><br><span class=\"line\">    i = <span class=\"number\">4</span>;</span><br><span class=\"line\">    j = <span class=\"number\">129</span>;</span><br><span class=\"line\">    k = <span class=\"number\">119</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">       <span class=\"keyword\">do</span></span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">while</span>(--k);</span><br><span class=\"line\">       &#125;<span class=\"keyword\">while</span>(--j);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(--i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)<span class=\"comment\">//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tP2 = <span class=\"number\">0xFE</span>;<span class=\"comment\">//点亮第一个LED</span></span><br><span class=\"line\">        Delay500ms();<span class=\"comment\">//调用延时函数</span></span><br><span class=\"line\">        P2 = <span class=\"number\">0xFF</span>;<span class=\"comment\">//全部熄灭</span></span><br><span class=\"line\">        Delay500ms();<span class=\"comment\">//调用延时函数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"编译下载\"><a href=\"#编译下载\" class=\"headerlink\" title=\"编译下载\"></a>编译下载</h4><p>请参考<code>1-1点亮LED</code>中的<code>4.编译与下载</code>文章，切记编译时要点击勾选工具栏中的<code>create HEX File</code>项，以生成可执行文件</p>\n<hr>\n<h2 id=\"1-3-LED流水灯\"><a href=\"#1-3-LED流水灯\" class=\"headerlink\" title=\"1-3 LED流水灯\"></a>1-3 LED流水灯</h2><h3 id=\"1-程序逻辑-1\"><a href=\"#1-程序逻辑-1\" class=\"headerlink\" title=\"1.程序逻辑\"></a>1.程序逻辑</h3><h5 id=\"程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\"><a href=\"#程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\" class=\"headerlink\" title=\"程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。\"></a>程序需求：使八个LED灯依次闪烁，每个灯亮时间可以在程序设计阶段修改，重复循环。</h5><h5 id=\"编写逻辑-1\"><a href=\"#编写逻辑-1\" class=\"headerlink\" title=\"编写逻辑\"></a>编写逻辑</h5><ul>\n<li>需要编写一个重复空运行1ms，不执行任何操作的延时函数，形参列表可以接受无符号整型，延时时间受形参列表控制</li>\n<li>需要一个死循环，其内部执行:点亮第一个LED -&gt; 延时设定时间 -&gt; 点亮第二个LED -&gt; 延时设定时间-&gt;············直到第八个，重复此过程</li>\n</ul>\n<h3 id=\"2-程序编写-1\"><a href=\"#2-程序编写-1\" class=\"headerlink\" title=\"2.程序编写\"></a>2.程序编写</h3><h4 id=\"创建工程-1\"><a href=\"#创建工程-1\" class=\"headerlink\" title=\"创建工程\"></a>创建工程</h4><p>创建工程请参考<code>1-1点亮LED</code>的教程</p>\n<h4 id=\"编写代码-1\"><a href=\"#编写代码-1\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><h6 id=\"延时函数-1\"><a href=\"#延时函数-1\" class=\"headerlink\" title=\"延时函数\"></a>延时函数</h6><p>首先，按照程序逻辑，需要编写一个延时函数，延时函数可以通过使用STC-ISP下载器中自带的<strong>软件延时计算器</strong>来生成函数</p>\n<p>食用方法</p>\n<ol>\n<li>设定系统频率，江科大使用的晶振频率是<code>12MHz</code>，目前各大购物平台出售的开发板更多使用<code>11.0592MHz</code>，具体数据请询问店家或自行查看晶振上的参数。</li>\n<li>设置定时长度，注意单位是毫秒还是秒</li>\n<li>8051指令集选择<code>STC-Y1</code>,此指令集适用于<code>STC89Cxx/STC89LExx/STC90Cxx/STC90LExx</code>系列</li>\n<li>设定好参数后，点击<code>生成C代码</code>,<strong>将其复制到程序中</strong></li>\n</ol>\n<h6 id=\"完整代码-1\"><a href=\"#完整代码-1\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h6><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;REGX52.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//添加51单片机程序的头文件，使程序可以为串口赋值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;INTRINS.H&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//此为延时函数运行所需要的头文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Delay1ms</span><span class=\"params\">(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> xms)</span><span class=\"comment\">//延时函数，通过重复空运行实现 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> i,j;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(xms)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      i = <span class=\"number\">2</span>;</span><br><span class=\"line\">      j = <span class=\"number\">239</span>;</span><br><span class=\"line\">     <span class=\"keyword\">do</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">           <span class=\"keyword\">while</span>(--j);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(--i);</span><br><span class=\"line\">        xms--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)<span class=\"comment\">//while的判断语句填写1即为非零的数，使判断始终为真，成为死循环</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    \tP2 = <span class=\"number\">0xFE</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">123</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xFD</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">213</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xFB</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">312</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xF7</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">234</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xEF</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">432</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xDF</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">345</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0xBF</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">645</span>);</span><br><span class=\"line\">        P2 = <span class=\"number\">0x7F</span>;</span><br><span class=\"line\">        Delay1ms(<span class=\"number\">234</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译下载-1\"><a href=\"#编译下载-1\" class=\"headerlink\" title=\"编译下载\"></a>编译下载</h4><p>请参考<code>1-1点亮LED</code>中的<code>4.编译与下载</code>文章，切记编译时要点击勾选工具栏中的<code>create HEX File</code>项，以生成可执行文件</p>\n<hr>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><ul>\n<li>VCC是正极，GND是负极</li>\n<li>LED的图标为下图，在作为图标时，左正右负；实物LED查看内电极用于分辨，较小的电极为正电极，较大的为负电极。</li>\n</ul>\n<p><a href=\"https://bu.dusays.com/2023/05/07/6456ea78a1c37.png\"><img src=\"https://bu.dusays.com/2023/05/07/6456ea78a1c37.png\" alt=\"发光二极管.png\"></a>g)</p>\n<ul>\n<li>电阻102=1K，10为有效数据，2为倍率；例如473即为47 000 = 47K；例如1001 = 100 0 = 1K。也就是说：共有三位时，前二位正常抄，第三位是几就在前两位后加几个零；共有四位时，前三位照抄，第四位是几就加几个零。</li>\n<li>单片机中，引脚实际输出时5V(高电平)或0V(低电平)，便于理解，可以理解为输出的是 + 或 -.</li>\n<li>高低电平在单片机中使用的是”TTL电平”(一种协议规范，相当于规定+是5V，-是0V)</li>\n</ul>\n"},{"title":"笔记：堆和栈的区别","_content":"\n\n# 笔记：堆和栈的区别\n\n在计算机中，堆和栈都是用于存储数据的内存区域。它们之间的**主要区别**在于**内存分配的方式**和**数据的生命周期**。\n\n## 堆的定义\n\n**堆**是一种**动态内存**分配的机制，通过在运行时分配和释放内存来存储数据。在堆中，数据的生命周期由程序员来控制，程序员需要负责在不再需要数据时手动释放内存，否则就可能会导致内存泄漏等问题。堆的内存分配方式是动态的，因此堆中的数据可以根据需要动态增长或缩减。\n\n## 栈的定义\n\n**栈**是一种**静态内存分配**的机制，通过在编译时分配内存来存储数据。在栈中，数据的生命周期是自动管理的，当一个函数或程序块执行完毕时，栈中的数据就会被自动释放。因此，在栈中创建的数据通常只在函数或程序块的生命周期内有效。栈的内存分配方式是静态的，因此栈中的数据大小是固定的。\n\n## 堆和栈的区别\n\n总的来说，堆和栈各有优劣。\n\n**堆具有灵活性和动态性，但需要程序员手动管理内存，容易导致内存泄漏等问题。**\n\n**栈具有自动管理内存的优点，但数据的生命周期受限于函数或程序块的生命周期，并且大小是固定的。**\n\n在实际编程中，我们需要根据不同的需求来选择使用堆还是栈来存储数据。\n\n## 全局变量与堆变量的区别\n\n**全局变量**和在**堆上创建的变量**有些相似，它们**都是在程序运行时分配的内存空间**。但是它们的**内存分配**和**释放方式**是**不同的**。\n\n**全局变量**是在程序编译时分配内存的，它们的**生命周期贯穿整个程序运行的周期**，直到程序退出才会被释放。全局变量的内**存分配和释放是自动管理**的，程序员不需要手动管理它们。\n\n**堆上创建的变量**是在程序运行时**动态分配的内存空间**，它们的**生命周期由程序员手动管理**。程序员需要手动分配内存空间，并在不需要时手动释放内存空间。如果程序员没有释放堆上的变量，就会导致内存泄漏的问题。\n\n因此，尽管全局变量和堆上的变量都是在程序运行时动态分配的内存空间，但是它们的内存分配和释放方式是不同的，程序员需要根据实际需求进行选择。\n\n#### 总结\n\n全局变量是在程序启动时就被分配在内存中的，直到程序结束才被释放。而堆变量是在程序运行时动态分配的，需要手动释放，否则会出现内存泄漏的问题。\n","source":"_posts/笔记：堆和栈的区别.md","raw":"---\ntitle: 笔记：堆和栈的区别\n---\n\n\n# 笔记：堆和栈的区别\n\n在计算机中，堆和栈都是用于存储数据的内存区域。它们之间的**主要区别**在于**内存分配的方式**和**数据的生命周期**。\n\n## 堆的定义\n\n**堆**是一种**动态内存**分配的机制，通过在运行时分配和释放内存来存储数据。在堆中，数据的生命周期由程序员来控制，程序员需要负责在不再需要数据时手动释放内存，否则就可能会导致内存泄漏等问题。堆的内存分配方式是动态的，因此堆中的数据可以根据需要动态增长或缩减。\n\n## 栈的定义\n\n**栈**是一种**静态内存分配**的机制，通过在编译时分配内存来存储数据。在栈中，数据的生命周期是自动管理的，当一个函数或程序块执行完毕时，栈中的数据就会被自动释放。因此，在栈中创建的数据通常只在函数或程序块的生命周期内有效。栈的内存分配方式是静态的，因此栈中的数据大小是固定的。\n\n## 堆和栈的区别\n\n总的来说，堆和栈各有优劣。\n\n**堆具有灵活性和动态性，但需要程序员手动管理内存，容易导致内存泄漏等问题。**\n\n**栈具有自动管理内存的优点，但数据的生命周期受限于函数或程序块的生命周期，并且大小是固定的。**\n\n在实际编程中，我们需要根据不同的需求来选择使用堆还是栈来存储数据。\n\n## 全局变量与堆变量的区别\n\n**全局变量**和在**堆上创建的变量**有些相似，它们**都是在程序运行时分配的内存空间**。但是它们的**内存分配**和**释放方式**是**不同的**。\n\n**全局变量**是在程序编译时分配内存的，它们的**生命周期贯穿整个程序运行的周期**，直到程序退出才会被释放。全局变量的内**存分配和释放是自动管理**的，程序员不需要手动管理它们。\n\n**堆上创建的变量**是在程序运行时**动态分配的内存空间**，它们的**生命周期由程序员手动管理**。程序员需要手动分配内存空间，并在不需要时手动释放内存空间。如果程序员没有释放堆上的变量，就会导致内存泄漏的问题。\n\n因此，尽管全局变量和堆上的变量都是在程序运行时动态分配的内存空间，但是它们的内存分配和释放方式是不同的，程序员需要根据实际需求进行选择。\n\n#### 总结\n\n全局变量是在程序启动时就被分配在内存中的，直到程序结束才被释放。而堆变量是在程序运行时动态分配的，需要手动释放，否则会出现内存泄漏的问题。\n","slug":"笔记：堆和栈的区别","published":1,"date":"2023-12-09T10:24:12.692Z","updated":"2023-03-25T08:38:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpxwwhz60005lc4dbvbt4cn9","content":"<h1 id=\"笔记：堆和栈的区别\"><a href=\"#笔记：堆和栈的区别\" class=\"headerlink\" title=\"笔记：堆和栈的区别\"></a>笔记：堆和栈的区别</h1><p>在计算机中，堆和栈都是用于存储数据的内存区域。它们之间的<strong>主要区别</strong>在于<strong>内存分配的方式</strong>和<strong>数据的生命周期</strong>。</p>\n<h2 id=\"堆的定义\"><a href=\"#堆的定义\" class=\"headerlink\" title=\"堆的定义\"></a>堆的定义</h2><p><strong>堆</strong>是一种<strong>动态内存</strong>分配的机制，通过在运行时分配和释放内存来存储数据。在堆中，数据的生命周期由程序员来控制，程序员需要负责在不再需要数据时手动释放内存，否则就可能会导致内存泄漏等问题。堆的内存分配方式是动态的，因此堆中的数据可以根据需要动态增长或缩减。</p>\n<h2 id=\"栈的定义\"><a href=\"#栈的定义\" class=\"headerlink\" title=\"栈的定义\"></a>栈的定义</h2><p><strong>栈</strong>是一种<strong>静态内存分配</strong>的机制，通过在编译时分配内存来存储数据。在栈中，数据的生命周期是自动管理的，当一个函数或程序块执行完毕时，栈中的数据就会被自动释放。因此，在栈中创建的数据通常只在函数或程序块的生命周期内有效。栈的内存分配方式是静态的，因此栈中的数据大小是固定的。</p>\n<h2 id=\"堆和栈的区别\"><a href=\"#堆和栈的区别\" class=\"headerlink\" title=\"堆和栈的区别\"></a>堆和栈的区别</h2><p>总的来说，堆和栈各有优劣。</p>\n<p><strong>堆具有灵活性和动态性，但需要程序员手动管理内存，容易导致内存泄漏等问题。</strong></p>\n<p><strong>栈具有自动管理内存的优点，但数据的生命周期受限于函数或程序块的生命周期，并且大小是固定的。</strong></p>\n<p>在实际编程中，我们需要根据不同的需求来选择使用堆还是栈来存储数据。</p>\n<h2 id=\"全局变量与堆变量的区别\"><a href=\"#全局变量与堆变量的区别\" class=\"headerlink\" title=\"全局变量与堆变量的区别\"></a>全局变量与堆变量的区别</h2><p><strong>全局变量</strong>和在<strong>堆上创建的变量</strong>有些相似，它们<strong>都是在程序运行时分配的内存空间</strong>。但是它们的<strong>内存分配</strong>和<strong>释放方式</strong>是<strong>不同的</strong>。</p>\n<p><strong>全局变量</strong>是在程序编译时分配内存的，它们的<strong>生命周期贯穿整个程序运行的周期</strong>，直到程序退出才会被释放。全局变量的内<strong>存分配和释放是自动管理</strong>的，程序员不需要手动管理它们。</p>\n<p><strong>堆上创建的变量</strong>是在程序运行时<strong>动态分配的内存空间</strong>，它们的<strong>生命周期由程序员手动管理</strong>。程序员需要手动分配内存空间，并在不需要时手动释放内存空间。如果程序员没有释放堆上的变量，就会导致内存泄漏的问题。</p>\n<p>因此，尽管全局变量和堆上的变量都是在程序运行时动态分配的内存空间，但是它们的内存分配和释放方式是不同的，程序员需要根据实际需求进行选择。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>全局变量是在程序启动时就被分配在内存中的，直到程序结束才被释放。而堆变量是在程序运行时动态分配的，需要手动释放，否则会出现内存泄漏的问题。</p>\n","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":"<h1 id=\"笔记：堆和栈的区别\"><a href=\"#笔记：堆和栈的区别\" class=\"headerlink\" title=\"笔记：堆和栈的区别\"></a>笔记：堆和栈的区别</h1><p>在计算机中，堆和栈都是用于存储数据的内存区域。它们之间的<strong>主要区别</strong>在于<strong>内存分配的方式</strong>和<strong>数据的生命周期</strong>。</p>\n<h2 id=\"堆的定义\"><a href=\"#堆的定义\" class=\"headerlink\" title=\"堆的定义\"></a>堆的定义</h2><p><strong>堆</strong>是一种<strong>动态内存</strong>分配的机制，通过在运行时分配和释放内存来存储数据。在堆中，数据的生命周期由程序员来控制，程序员需要负责在不再需要数据时手动释放内存，否则就可能会导致内存泄漏等问题。堆的内存分配方式是动态的，因此堆中的数据可以根据需要动态增长或缩减。</p>\n<h2 id=\"栈的定义\"><a href=\"#栈的定义\" class=\"headerlink\" title=\"栈的定义\"></a>栈的定义</h2><p><strong>栈</strong>是一种<strong>静态内存分配</strong>的机制，通过在编译时分配内存来存储数据。在栈中，数据的生命周期是自动管理的，当一个函数或程序块执行完毕时，栈中的数据就会被自动释放。因此，在栈中创建的数据通常只在函数或程序块的生命周期内有效。栈的内存分配方式是静态的，因此栈中的数据大小是固定的。</p>\n<h2 id=\"堆和栈的区别\"><a href=\"#堆和栈的区别\" class=\"headerlink\" title=\"堆和栈的区别\"></a>堆和栈的区别</h2><p>总的来说，堆和栈各有优劣。</p>\n<p><strong>堆具有灵活性和动态性，但需要程序员手动管理内存，容易导致内存泄漏等问题。</strong></p>\n<p><strong>栈具有自动管理内存的优点，但数据的生命周期受限于函数或程序块的生命周期，并且大小是固定的。</strong></p>\n<p>在实际编程中，我们需要根据不同的需求来选择使用堆还是栈来存储数据。</p>\n<h2 id=\"全局变量与堆变量的区别\"><a href=\"#全局变量与堆变量的区别\" class=\"headerlink\" title=\"全局变量与堆变量的区别\"></a>全局变量与堆变量的区别</h2><p><strong>全局变量</strong>和在<strong>堆上创建的变量</strong>有些相似，它们<strong>都是在程序运行时分配的内存空间</strong>。但是它们的<strong>内存分配</strong>和<strong>释放方式</strong>是<strong>不同的</strong>。</p>\n<p><strong>全局变量</strong>是在程序编译时分配内存的，它们的<strong>生命周期贯穿整个程序运行的周期</strong>，直到程序退出才会被释放。全局变量的内<strong>存分配和释放是自动管理</strong>的，程序员不需要手动管理它们。</p>\n<p><strong>堆上创建的变量</strong>是在程序运行时<strong>动态分配的内存空间</strong>，它们的<strong>生命周期由程序员手动管理</strong>。程序员需要手动分配内存空间，并在不需要时手动释放内存空间。如果程序员没有释放堆上的变量，就会导致内存泄漏的问题。</p>\n<p>因此，尽管全局变量和堆上的变量都是在程序运行时动态分配的内存空间，但是它们的内存分配和释放方式是不同的，程序员需要根据实际需求进行选择。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>全局变量是在程序启动时就被分配在内存中的，直到程序结束才被释放。而堆变量是在程序运行时动态分配的，需要手动释放，否则会出现内存泄漏的问题。</p>\n"},{"title":"笔记：类和结构的定义与区别","_content":"\n# 笔记：类和结构的定义与区别\n\n## 定义\n\n类和结构是面向对象编程中的两个重要概念，它们是用于定义数据类型和实现相关操作的基本工具之一。下面是类和结构的定义方式及其区别：\n\n#### 类的定义：\n\n类是一种自定义的数据类型，用于表示某个具体对象的属性和行为。类定义了对象的特征和行为，并提供了对它们的操作。类的定义方式通常如下：\n\n```c#\nclass ClassName\n{\n    // 类成员的定义\n}\n\n```\n\n其中，`class` 是 C# 中定义类的关键字，`ClassName` 是自定义的类名称。在类体内，可以定义类的成员，包括字段、属性、方法、构造函数、静态成员等等。类的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。\n\n#### 结构的定义：\n\n结构是一种自定义的值类型数据类型，用于表示某个数据的属性和行为。与类不同的是，结构是通过值传递而不是引用传递的方式来传递数据。结构的定义方式通常如下：\n\n```c#\nstruct StructName\n{\n    // 结构成员的定义\n}\n\n```\n\n其中，`struct` 是 C# 中定义结构的关键字，`StructName` 是自定义的结构名称。在结构体体内，可以定义结构的成员，包括字段、属性、方法、构造函数、静态成员等等。结构的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。\n\n**需要注意的是，结构的大小通常比类小，因为结构体通常是值类型，在栈中分配。此外，结构体通常用于表示简单的数据类型，例如坐标、日期、颜色等等，而类则通常用于表示复杂的对象，例如人、车、房屋等等**\n\n\n\n## 类和结构的区别\n\n1.类和结构的默认访问修饰符不同：类的默认访问修饰符是 internal，而结构的默认访问修饰符是 public。\n\n2.类和结构的实例化方式不同：类的实例化需要使用 new 关键字，而结构可以使用 new 关键字，也可以不使用。\n\n3.类和结构的传递方式不同：类是引用类型，传递时传递的是引用的副本；而结构是值类型，传递时传递的是值的副本。\n\n4.类和结构的继承方式不同：类支持单继承和多重继承，而结构只支持单继承。\n\n<!--关于单双继承的定义以及区见“笔记：继承以及单双继承的含义以及区别”-->\n\n5.类和结构的大小不同：由于类的实例通常在堆上分配，所以类的大小可能比结构的大小大很多。\n\n\n\n## 对于第三条引用类型不同（值传递和引用传递的区别）的解释\n\n值传递和引用传递是两种不同的数据传递方式，它们的主要区别在于传递的方式和传递数据的副本。\n\n#### 值传递\n\n值传递是指将一个变量的值复制到另一个变量，然后传递该值的副本。在这种情况下，函数或方法中的参数是原始值的副本，对参数的修改不会影响原始值。在值传递中，对于基本数据类型（例如 int、float、double 等）和结构体类型，变量的值被传递给函数或方法，而不是对变量的引用或指针。这意味着在函数或方法中对参数进行更改时，不会影响原始变量的值。\n\n```c++\n#include <iostream>\n\nvoid ModifyValue(int value)\n{\n    value = 20;\n}\n\nint main()\n{\n    int x = 10;\n    std::cout << \"原始值：\" << x << std::endl; // 输出：原始值：10\n\n    ModifyValue(x);\n    std::cout << \"修改后的值：\" << x << std::endl; // 输出：修改后的值：10\n\n    return 0;\n}\n\n```\n\n在上面的代码中，函数 `ModifyValue` 采用了值传递方式，即将变量 `x` 的值复制到函数参数 `value` 中。在函数中对参数 `value` 的更改**不会影响原始变量** `x` **的值。**\n\n#### 引用传递\n\n引用传递是指将变量的引用（或指针）传递给函数或方法，而不是变量的副本。在这种情况下，函数或方法中的参数是变量的引用，对参数的修改会影响原始变量的值。在引用传递中，对于类类型和数组类型，变量的引用被传递给函数或方法，而不是对变量的值进行传递。这意味着在函数或方法中对参数进行更改时，会影响原始变量的值。\n\n```c++\n#include <iostream>\n\nvoid ModifyValue(int& value)\n{\n    value = 10;\n}\n\nint main()\n{\n    int x = 5;\n    std::cout << \"原始值：\" << x << std::endl; // 输出：原始值：5\n\n    ModifyValue(x);\n    std::cout << \"修改后的值：\" << x << std::endl; // 输出：修改后的值：10\n\n    return 0;\n}\n\n```\n\n在上面的代码中，函数 `ModifyValue` 采用了引用传递方式，即将变量 `x` 的引用传递给函数参数 `value` 中。在函数中对参数 `value` 的更改**会影响到原始变量** `x` **的值。**\n\n##### 总结\n\n总的来说，在值传递中，传入函数的是参数的值的一个副本，因此函数对参数进行修改不会影响到原始变量的值。而在引用传递中，传入函数的是参数的引用（地址），函数对参数进行的任何修改都会影响到原始变量的值，因为它们实际上指向同一块内存地址。\n\n\n\n","source":"_posts/笔记：类和结构的区别.md","raw":"---\ntitle: 笔记：类和结构的定义与区别\n---\n\n# 笔记：类和结构的定义与区别\n\n## 定义\n\n类和结构是面向对象编程中的两个重要概念，它们是用于定义数据类型和实现相关操作的基本工具之一。下面是类和结构的定义方式及其区别：\n\n#### 类的定义：\n\n类是一种自定义的数据类型，用于表示某个具体对象的属性和行为。类定义了对象的特征和行为，并提供了对它们的操作。类的定义方式通常如下：\n\n```c#\nclass ClassName\n{\n    // 类成员的定义\n}\n\n```\n\n其中，`class` 是 C# 中定义类的关键字，`ClassName` 是自定义的类名称。在类体内，可以定义类的成员，包括字段、属性、方法、构造函数、静态成员等等。类的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。\n\n#### 结构的定义：\n\n结构是一种自定义的值类型数据类型，用于表示某个数据的属性和行为。与类不同的是，结构是通过值传递而不是引用传递的方式来传递数据。结构的定义方式通常如下：\n\n```c#\nstruct StructName\n{\n    // 结构成员的定义\n}\n\n```\n\n其中，`struct` 是 C# 中定义结构的关键字，`StructName` 是自定义的结构名称。在结构体体内，可以定义结构的成员，包括字段、属性、方法、构造函数、静态成员等等。结构的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。\n\n**需要注意的是，结构的大小通常比类小，因为结构体通常是值类型，在栈中分配。此外，结构体通常用于表示简单的数据类型，例如坐标、日期、颜色等等，而类则通常用于表示复杂的对象，例如人、车、房屋等等**\n\n\n\n## 类和结构的区别\n\n1.类和结构的默认访问修饰符不同：类的默认访问修饰符是 internal，而结构的默认访问修饰符是 public。\n\n2.类和结构的实例化方式不同：类的实例化需要使用 new 关键字，而结构可以使用 new 关键字，也可以不使用。\n\n3.类和结构的传递方式不同：类是引用类型，传递时传递的是引用的副本；而结构是值类型，传递时传递的是值的副本。\n\n4.类和结构的继承方式不同：类支持单继承和多重继承，而结构只支持单继承。\n\n<!--关于单双继承的定义以及区见“笔记：继承以及单双继承的含义以及区别”-->\n\n5.类和结构的大小不同：由于类的实例通常在堆上分配，所以类的大小可能比结构的大小大很多。\n\n\n\n## 对于第三条引用类型不同（值传递和引用传递的区别）的解释\n\n值传递和引用传递是两种不同的数据传递方式，它们的主要区别在于传递的方式和传递数据的副本。\n\n#### 值传递\n\n值传递是指将一个变量的值复制到另一个变量，然后传递该值的副本。在这种情况下，函数或方法中的参数是原始值的副本，对参数的修改不会影响原始值。在值传递中，对于基本数据类型（例如 int、float、double 等）和结构体类型，变量的值被传递给函数或方法，而不是对变量的引用或指针。这意味着在函数或方法中对参数进行更改时，不会影响原始变量的值。\n\n```c++\n#include <iostream>\n\nvoid ModifyValue(int value)\n{\n    value = 20;\n}\n\nint main()\n{\n    int x = 10;\n    std::cout << \"原始值：\" << x << std::endl; // 输出：原始值：10\n\n    ModifyValue(x);\n    std::cout << \"修改后的值：\" << x << std::endl; // 输出：修改后的值：10\n\n    return 0;\n}\n\n```\n\n在上面的代码中，函数 `ModifyValue` 采用了值传递方式，即将变量 `x` 的值复制到函数参数 `value` 中。在函数中对参数 `value` 的更改**不会影响原始变量** `x` **的值。**\n\n#### 引用传递\n\n引用传递是指将变量的引用（或指针）传递给函数或方法，而不是变量的副本。在这种情况下，函数或方法中的参数是变量的引用，对参数的修改会影响原始变量的值。在引用传递中，对于类类型和数组类型，变量的引用被传递给函数或方法，而不是对变量的值进行传递。这意味着在函数或方法中对参数进行更改时，会影响原始变量的值。\n\n```c++\n#include <iostream>\n\nvoid ModifyValue(int& value)\n{\n    value = 10;\n}\n\nint main()\n{\n    int x = 5;\n    std::cout << \"原始值：\" << x << std::endl; // 输出：原始值：5\n\n    ModifyValue(x);\n    std::cout << \"修改后的值：\" << x << std::endl; // 输出：修改后的值：10\n\n    return 0;\n}\n\n```\n\n在上面的代码中，函数 `ModifyValue` 采用了引用传递方式，即将变量 `x` 的引用传递给函数参数 `value` 中。在函数中对参数 `value` 的更改**会影响到原始变量** `x` **的值。**\n\n##### 总结\n\n总的来说，在值传递中，传入函数的是参数的值的一个副本，因此函数对参数进行修改不会影响到原始变量的值。而在引用传递中，传入函数的是参数的引用（地址），函数对参数进行的任何修改都会影响到原始变量的值，因为它们实际上指向同一块内存地址。\n\n\n\n","slug":"笔记：类和结构的区别","published":1,"date":"2023-12-09T10:24:12.690Z","updated":"2023-03-25T08:41:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpxwwhz70007lc4d3a3j46j8","content":"<h1 id=\"笔记：类和结构的定义与区别\"><a href=\"#笔记：类和结构的定义与区别\" class=\"headerlink\" title=\"笔记：类和结构的定义与区别\"></a>笔记：类和结构的定义与区别</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>类和结构是面向对象编程中的两个重要概念，它们是用于定义数据类型和实现相关操作的基本工具之一。下面是类和结构的定义方式及其区别：</p>\n<h4 id=\"类的定义：\"><a href=\"#类的定义：\" class=\"headerlink\" title=\"类的定义：\"></a>类的定义：</h4><p>类是一种自定义的数据类型，用于表示某个具体对象的属性和行为。类定义了对象的特征和行为，并提供了对它们的操作。类的定义方式通常如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ClassName</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类成员的定义</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>class</code> 是 C# 中定义类的关键字，<code>ClassName</code> 是自定义的类名称。在类体内，可以定义类的成员，包括字段、属性、方法、构造函数、静态成员等等。类的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。</p>\n<h4 id=\"结构的定义：\"><a href=\"#结构的定义：\" class=\"headerlink\" title=\"结构的定义：\"></a>结构的定义：</h4><p>结构是一种自定义的值类型数据类型，用于表示某个数据的属性和行为。与类不同的是，结构是通过值传递而不是引用传递的方式来传递数据。结构的定义方式通常如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> StructName</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结构成员的定义</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>struct</code> 是 C# 中定义结构的关键字，<code>StructName</code> 是自定义的结构名称。在结构体体内，可以定义结构的成员，包括字段、属性、方法、构造函数、静态成员等等。结构的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。</p>\n<p><strong>需要注意的是，结构的大小通常比类小，因为结构体通常是值类型，在栈中分配。此外，结构体通常用于表示简单的数据类型，例如坐标、日期、颜色等等，而类则通常用于表示复杂的对象，例如人、车、房屋等等</strong></p>\n<h2 id=\"类和结构的区别\"><a href=\"#类和结构的区别\" class=\"headerlink\" title=\"类和结构的区别\"></a>类和结构的区别</h2><p>1.类和结构的默认访问修饰符不同：类的默认访问修饰符是 internal，而结构的默认访问修饰符是 public。</p>\n<p>2.类和结构的实例化方式不同：类的实例化需要使用 new 关键字，而结构可以使用 new 关键字，也可以不使用。</p>\n<p>3.类和结构的传递方式不同：类是引用类型，传递时传递的是引用的副本；而结构是值类型，传递时传递的是值的副本。</p>\n<p>4.类和结构的继承方式不同：类支持单继承和多重继承，而结构只支持单继承。</p>\n<!--关于单双继承的定义以及区见“笔记：继承以及单双继承的含义以及区别”-->\n\n<p>5.类和结构的大小不同：由于类的实例通常在堆上分配，所以类的大小可能比结构的大小大很多。</p>\n<h2 id=\"对于第三条引用类型不同（值传递和引用传递的区别）的解释\"><a href=\"#对于第三条引用类型不同（值传递和引用传递的区别）的解释\" class=\"headerlink\" title=\"对于第三条引用类型不同（值传递和引用传递的区别）的解释\"></a>对于第三条引用类型不同（值传递和引用传递的区别）的解释</h2><p>值传递和引用传递是两种不同的数据传递方式，它们的主要区别在于传递的方式和传递数据的副本。</p>\n<h4 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h4><p>值传递是指将一个变量的值复制到另一个变量，然后传递该值的副本。在这种情况下，函数或方法中的参数是原始值的副本，对参数的修改不会影响原始值。在值传递中，对于基本数据类型（例如 int、float、double 等）和结构体类型，变量的值被传递给函数或方法，而不是对变量的引用或指针。这意味着在函数或方法中对参数进行更改时，不会影响原始变量的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ModifyValue</span><span class=\"params\">(<span class=\"type\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    value = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;原始值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：原始值：10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ModifyValue</span>(x);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;修改后的值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：修改后的值：10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，函数 <code>ModifyValue</code> 采用了值传递方式，即将变量 <code>x</code> 的值复制到函数参数 <code>value</code> 中。在函数中对参数 <code>value</code> 的更改<strong>不会影响原始变量</strong> <code>x</code> <strong>的值。</strong></p>\n<h4 id=\"引用传递\"><a href=\"#引用传递\" class=\"headerlink\" title=\"引用传递\"></a>引用传递</h4><p>引用传递是指将变量的引用（或指针）传递给函数或方法，而不是变量的副本。在这种情况下，函数或方法中的参数是变量的引用，对参数的修改会影响原始变量的值。在引用传递中，对于类类型和数组类型，变量的引用被传递给函数或方法，而不是对变量的值进行传递。这意味着在函数或方法中对参数进行更改时，会影响原始变量的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ModifyValue</span><span class=\"params\">(<span class=\"type\">int</span>&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    value = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;原始值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：原始值：5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ModifyValue</span>(x);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;修改后的值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：修改后的值：10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，函数 <code>ModifyValue</code> 采用了引用传递方式，即将变量 <code>x</code> 的引用传递给函数参数 <code>value</code> 中。在函数中对参数 <code>value</code> 的更改<strong>会影响到原始变量</strong> <code>x</code> <strong>的值。</strong></p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>总的来说，在值传递中，传入函数的是参数的值的一个副本，因此函数对参数进行修改不会影响到原始变量的值。而在引用传递中，传入函数的是参数的引用（地址），函数对参数进行的任何修改都会影响到原始变量的值，因为它们实际上指向同一块内存地址。</p>\n","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":"<h1 id=\"笔记：类和结构的定义与区别\"><a href=\"#笔记：类和结构的定义与区别\" class=\"headerlink\" title=\"笔记：类和结构的定义与区别\"></a>笔记：类和结构的定义与区别</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>类和结构是面向对象编程中的两个重要概念，它们是用于定义数据类型和实现相关操作的基本工具之一。下面是类和结构的定义方式及其区别：</p>\n<h4 id=\"类的定义：\"><a href=\"#类的定义：\" class=\"headerlink\" title=\"类的定义：\"></a>类的定义：</h4><p>类是一种自定义的数据类型，用于表示某个具体对象的属性和行为。类定义了对象的特征和行为，并提供了对它们的操作。类的定义方式通常如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">ClassName</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 类成员的定义</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>class</code> 是 C# 中定义类的关键字，<code>ClassName</code> 是自定义的类名称。在类体内，可以定义类的成员，包括字段、属性、方法、构造函数、静态成员等等。类的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。</p>\n<h4 id=\"结构的定义：\"><a href=\"#结构的定义：\" class=\"headerlink\" title=\"结构的定义：\"></a>结构的定义：</h4><p>结构是一种自定义的值类型数据类型，用于表示某个数据的属性和行为。与类不同的是，结构是通过值传递而不是引用传递的方式来传递数据。结构的定义方式通常如下：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> StructName</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结构成员的定义</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>struct</code> 是 C# 中定义结构的关键字，<code>StructName</code> 是自定义的结构名称。在结构体体内，可以定义结构的成员，包括字段、属性、方法、构造函数、静态成员等等。结构的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。</p>\n<p><strong>需要注意的是，结构的大小通常比类小，因为结构体通常是值类型，在栈中分配。此外，结构体通常用于表示简单的数据类型，例如坐标、日期、颜色等等，而类则通常用于表示复杂的对象，例如人、车、房屋等等</strong></p>\n<h2 id=\"类和结构的区别\"><a href=\"#类和结构的区别\" class=\"headerlink\" title=\"类和结构的区别\"></a>类和结构的区别</h2><p>1.类和结构的默认访问修饰符不同：类的默认访问修饰符是 internal，而结构的默认访问修饰符是 public。</p>\n<p>2.类和结构的实例化方式不同：类的实例化需要使用 new 关键字，而结构可以使用 new 关键字，也可以不使用。</p>\n<p>3.类和结构的传递方式不同：类是引用类型，传递时传递的是引用的副本；而结构是值类型，传递时传递的是值的副本。</p>\n<p>4.类和结构的继承方式不同：类支持单继承和多重继承，而结构只支持单继承。</p>\n<!--关于单双继承的定义以及区见“笔记：继承以及单双继承的含义以及区别”-->\n\n<p>5.类和结构的大小不同：由于类的实例通常在堆上分配，所以类的大小可能比结构的大小大很多。</p>\n<h2 id=\"对于第三条引用类型不同（值传递和引用传递的区别）的解释\"><a href=\"#对于第三条引用类型不同（值传递和引用传递的区别）的解释\" class=\"headerlink\" title=\"对于第三条引用类型不同（值传递和引用传递的区别）的解释\"></a>对于第三条引用类型不同（值传递和引用传递的区别）的解释</h2><p>值传递和引用传递是两种不同的数据传递方式，它们的主要区别在于传递的方式和传递数据的副本。</p>\n<h4 id=\"值传递\"><a href=\"#值传递\" class=\"headerlink\" title=\"值传递\"></a>值传递</h4><p>值传递是指将一个变量的值复制到另一个变量，然后传递该值的副本。在这种情况下，函数或方法中的参数是原始值的副本，对参数的修改不会影响原始值。在值传递中，对于基本数据类型（例如 int、float、double 等）和结构体类型，变量的值被传递给函数或方法，而不是对变量的引用或指针。这意味着在函数或方法中对参数进行更改时，不会影响原始变量的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ModifyValue</span><span class=\"params\">(<span class=\"type\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    value = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;原始值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：原始值：10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ModifyValue</span>(x);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;修改后的值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：修改后的值：10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，函数 <code>ModifyValue</code> 采用了值传递方式，即将变量 <code>x</code> 的值复制到函数参数 <code>value</code> 中。在函数中对参数 <code>value</code> 的更改<strong>不会影响原始变量</strong> <code>x</code> <strong>的值。</strong></p>\n<h4 id=\"引用传递\"><a href=\"#引用传递\" class=\"headerlink\" title=\"引用传递\"></a>引用传递</h4><p>引用传递是指将变量的引用（或指针）传递给函数或方法，而不是变量的副本。在这种情况下，函数或方法中的参数是变量的引用，对参数的修改会影响原始变量的值。在引用传递中，对于类类型和数组类型，变量的引用被传递给函数或方法，而不是对变量的值进行传递。这意味着在函数或方法中对参数进行更改时，会影响原始变量的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ModifyValue</span><span class=\"params\">(<span class=\"type\">int</span>&amp; value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    value = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;原始值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：原始值：5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ModifyValue</span>(x);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;修改后的值：&quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class=\"comment\">// 输出：修改后的值：10</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，函数 <code>ModifyValue</code> 采用了引用传递方式，即将变量 <code>x</code> 的引用传递给函数参数 <code>value</code> 中。在函数中对参数 <code>value</code> 的更改<strong>会影响到原始变量</strong> <code>x</code> <strong>的值。</strong></p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>总的来说，在值传递中，传入函数的是参数的值的一个副本，因此函数对参数进行修改不会影响到原始变量的值。而在引用传递中，传入函数的是参数的引用（地址），函数对参数进行的任何修改都会影响到原始变量的值，因为它们实际上指向同一块内存地址。</p>\n"},{"title":"笔记：继承以及单、双继承的含义以及区别","_content":"\n##  继承的含义\n\n当我们在编写面向对象程序时，经常会遇到需要定义多个类，这些类之间可能会有一些共性，如属性、方法等。这时候，我们就可以考虑使用继承来简化代码，减少代码的重复性。\n\n继承是面向对象编程中的一种重要机制，它允许我们定义一个类（称为子类或派生类），它可以继承另一个类（称为父类或基类）的属性和方法。子类可以使用父类的所有公有和受保护的成员（属性和方法），并且还可以添加自己的成员，以扩展或修改父类的功能。\n\n在继承中，我们可以把父类的属性和方法分为两类：公有成员和受保护成员。公有成员是可以被子类访问和修改的，受保护成员只能在父类和子类内部访问和修改。\n\n#### 举个例子\n\n下面是一个使用继承的简单示例，其中 `Animal` 是父类，`Dog` 是子类：\n\n```c++\nclass Animal {\npublic:\n    void eat() {\n        std::cout << \"Animal is eating\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog is barking\" << std::endl;\n    }\n};\n\n```\n\n在上面的代码中，`Dog` 类继承了 `Animal` 类的公有成员 `eat()` 方法，因此 `Dog` 类也可以使用 `eat()` 方法。同时，`Dog` 类还添加了自己的成员 `bark()` 方法，以扩展父类的功能。\n\n也就是说 `Dog` 类继承了 `Animal` 类，因此 `Dog` 类可以直接使用 `Animal` 类中的公有成员 `eat()` 方法，无需在 `Dog` 类中重新定义。在 `Dog` 类的对象中，可以直接使用 `eat()` 方法，输出 `Animal is eating`。\n\n\n\n## 单继承以及多继承\n\n### 单继承\n\n单继承是指一个类只能继承自另外一个类，也就是说一个派生类只能有一个直接基类。\n\n例如：\n\n```c++\nclass Animal {\npublic:\n    void eat() {\n        std::cout << \"Animal is eating\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog is barking\" << std::endl;\n    }\n};\n\n```\n\n在上面的代码中，类 `Dog` 继承自类 `Animal`，这是单继承的示例。\n\n### 多继承\n\n多继承是指一个类可以同时继承自多个类，也就是说一个派生类可以有多个直接基类。\n\n例如：\n\n```c++\nclass Flyable {\npublic:\n    void fly() {\n        std::cout << \"I am flying\" << std::endl;\n    }\n};\n\nclass Bird {\npublic:\n    void sing() {\n        std::cout << \"Bird is singing\" << std::endl;\n    }\n};\n\nclass Pigeon : public Flyable, public Bird {\npublic:\n    void coo() {\n        std::cout << \"Pigeon is cooing\" << std::endl;\n    }\n};\n\n```\n\n在上面的代码中，类 `Pigeon` （鸽子）同时继承自类 `Flyable` （可飞行）和类 `Bird`（鸟），这是多继承的示例。\n\n\n\n**使用单继承和多继承都有其优缺点，单继承有较好的可维护性和易读性，但缺乏灵活性；多继承具有更高的灵活性，但可能会导致继承层次结构过于复杂和不易维护**\n\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n","source":"_posts/继承以及单、双继承的含义以及区别.md","raw":"---\ntitle: 笔记：继承以及单、双继承的含义以及区别\n---\n\n##  继承的含义\n\n当我们在编写面向对象程序时，经常会遇到需要定义多个类，这些类之间可能会有一些共性，如属性、方法等。这时候，我们就可以考虑使用继承来简化代码，减少代码的重复性。\n\n继承是面向对象编程中的一种重要机制，它允许我们定义一个类（称为子类或派生类），它可以继承另一个类（称为父类或基类）的属性和方法。子类可以使用父类的所有公有和受保护的成员（属性和方法），并且还可以添加自己的成员，以扩展或修改父类的功能。\n\n在继承中，我们可以把父类的属性和方法分为两类：公有成员和受保护成员。公有成员是可以被子类访问和修改的，受保护成员只能在父类和子类内部访问和修改。\n\n#### 举个例子\n\n下面是一个使用继承的简单示例，其中 `Animal` 是父类，`Dog` 是子类：\n\n```c++\nclass Animal {\npublic:\n    void eat() {\n        std::cout << \"Animal is eating\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog is barking\" << std::endl;\n    }\n};\n\n```\n\n在上面的代码中，`Dog` 类继承了 `Animal` 类的公有成员 `eat()` 方法，因此 `Dog` 类也可以使用 `eat()` 方法。同时，`Dog` 类还添加了自己的成员 `bark()` 方法，以扩展父类的功能。\n\n也就是说 `Dog` 类继承了 `Animal` 类，因此 `Dog` 类可以直接使用 `Animal` 类中的公有成员 `eat()` 方法，无需在 `Dog` 类中重新定义。在 `Dog` 类的对象中，可以直接使用 `eat()` 方法，输出 `Animal is eating`。\n\n\n\n## 单继承以及多继承\n\n### 单继承\n\n单继承是指一个类只能继承自另外一个类，也就是说一个派生类只能有一个直接基类。\n\n例如：\n\n```c++\nclass Animal {\npublic:\n    void eat() {\n        std::cout << \"Animal is eating\" << std::endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void bark() {\n        std::cout << \"Dog is barking\" << std::endl;\n    }\n};\n\n```\n\n在上面的代码中，类 `Dog` 继承自类 `Animal`，这是单继承的示例。\n\n### 多继承\n\n多继承是指一个类可以同时继承自多个类，也就是说一个派生类可以有多个直接基类。\n\n例如：\n\n```c++\nclass Flyable {\npublic:\n    void fly() {\n        std::cout << \"I am flying\" << std::endl;\n    }\n};\n\nclass Bird {\npublic:\n    void sing() {\n        std::cout << \"Bird is singing\" << std::endl;\n    }\n};\n\nclass Pigeon : public Flyable, public Bird {\npublic:\n    void coo() {\n        std::cout << \"Pigeon is cooing\" << std::endl;\n    }\n};\n\n```\n\n在上面的代码中，类 `Pigeon` （鸽子）同时继承自类 `Flyable` （可飞行）和类 `Bird`（鸟），这是多继承的示例。\n\n\n\n**使用单继承和多继承都有其优缺点，单继承有较好的可维护性和易读性，但缺乏灵活性；多继承具有更高的灵活性，但可能会导致继承层次结构过于复杂和不易维护**\n\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n","slug":"继承以及单、双继承的含义以及区别","published":1,"date":"2023-12-09T10:24:12.688Z","updated":"2023-03-25T08:41:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clpxwwhz80009lc4dap5qhtwg","content":"<h2 id=\"继承的含义\"><a href=\"#继承的含义\" class=\"headerlink\" title=\"继承的含义\"></a>继承的含义</h2><p>当我们在编写面向对象程序时，经常会遇到需要定义多个类，这些类之间可能会有一些共性，如属性、方法等。这时候，我们就可以考虑使用继承来简化代码，减少代码的重复性。</p>\n<p>继承是面向对象编程中的一种重要机制，它允许我们定义一个类（称为子类或派生类），它可以继承另一个类（称为父类或基类）的属性和方法。子类可以使用父类的所有公有和受保护的成员（属性和方法），并且还可以添加自己的成员，以扩展或修改父类的功能。</p>\n<p>在继承中，我们可以把父类的属性和方法分为两类：公有成员和受保护成员。公有成员是可以被子类访问和修改的，受保护成员只能在父类和子类内部访问和修改。</p>\n<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p>下面是一个使用继承的简单示例，其中 <code>Animal</code> 是父类，<code>Dog</code> 是子类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Animal is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Dog is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，<code>Dog</code> 类继承了 <code>Animal</code> 类的公有成员 <code>eat()</code> 方法，因此 <code>Dog</code> 类也可以使用 <code>eat()</code> 方法。同时，<code>Dog</code> 类还添加了自己的成员 <code>bark()</code> 方法，以扩展父类的功能。</p>\n<p>也就是说 <code>Dog</code> 类继承了 <code>Animal</code> 类，因此 <code>Dog</code> 类可以直接使用 <code>Animal</code> 类中的公有成员 <code>eat()</code> 方法，无需在 <code>Dog</code> 类中重新定义。在 <code>Dog</code> 类的对象中，可以直接使用 <code>eat()</code> 方法，输出 <code>Animal is eating</code>。</p>\n<h2 id=\"单继承以及多继承\"><a href=\"#单继承以及多继承\" class=\"headerlink\" title=\"单继承以及多继承\"></a>单继承以及多继承</h2><h3 id=\"单继承\"><a href=\"#单继承\" class=\"headerlink\" title=\"单继承\"></a>单继承</h3><p>单继承是指一个类只能继承自另外一个类，也就是说一个派生类只能有一个直接基类。</p>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Animal is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Dog is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，类 <code>Dog</code> 继承自类 <code>Animal</code>，这是单继承的示例。</p>\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>多继承是指一个类可以同时继承自多个类，也就是说一个派生类可以有多个直接基类。</p>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;I am flying&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sing</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Bird is singing&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pigeon</span> : <span class=\"keyword\">public</span> Flyable, <span class=\"keyword\">public</span> Bird &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">coo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Pigeon is cooing&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，类 <code>Pigeon</code> （鸽子）同时继承自类 <code>Flyable</code> （可飞行）和类 <code>Bird</code>（鸟），这是多继承的示例。</p>\n<p><strong>使用单继承和多继承都有其优缺点，单继承有较好的可维护性和易读性，但缺乏灵活性；多继承具有更高的灵活性，但可能会导致继承层次结构过于复杂和不易维护</strong></p>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"cover":"https://bu.dusays.com/2022/12/02/638990593f661.jpg","excerpt":"","more":"<h2 id=\"继承的含义\"><a href=\"#继承的含义\" class=\"headerlink\" title=\"继承的含义\"></a>继承的含义</h2><p>当我们在编写面向对象程序时，经常会遇到需要定义多个类，这些类之间可能会有一些共性，如属性、方法等。这时候，我们就可以考虑使用继承来简化代码，减少代码的重复性。</p>\n<p>继承是面向对象编程中的一种重要机制，它允许我们定义一个类（称为子类或派生类），它可以继承另一个类（称为父类或基类）的属性和方法。子类可以使用父类的所有公有和受保护的成员（属性和方法），并且还可以添加自己的成员，以扩展或修改父类的功能。</p>\n<p>在继承中，我们可以把父类的属性和方法分为两类：公有成员和受保护成员。公有成员是可以被子类访问和修改的，受保护成员只能在父类和子类内部访问和修改。</p>\n<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p>下面是一个使用继承的简单示例，其中 <code>Animal</code> 是父类，<code>Dog</code> 是子类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Animal is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Dog is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，<code>Dog</code> 类继承了 <code>Animal</code> 类的公有成员 <code>eat()</code> 方法，因此 <code>Dog</code> 类也可以使用 <code>eat()</code> 方法。同时，<code>Dog</code> 类还添加了自己的成员 <code>bark()</code> 方法，以扩展父类的功能。</p>\n<p>也就是说 <code>Dog</code> 类继承了 <code>Animal</code> 类，因此 <code>Dog</code> 类可以直接使用 <code>Animal</code> 类中的公有成员 <code>eat()</code> 方法，无需在 <code>Dog</code> 类中重新定义。在 <code>Dog</code> 类的对象中，可以直接使用 <code>eat()</code> 方法，输出 <code>Animal is eating</code>。</p>\n<h2 id=\"单继承以及多继承\"><a href=\"#单继承以及多继承\" class=\"headerlink\" title=\"单继承以及多继承\"></a>单继承以及多继承</h2><h3 id=\"单继承\"><a href=\"#单继承\" class=\"headerlink\" title=\"单继承\"></a>单继承</h3><p>单继承是指一个类只能继承自另外一个类，也就是说一个派生类只能有一个直接基类。</p>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">eat</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Animal is eating&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Dog is barking&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，类 <code>Dog</code> 继承自类 <code>Animal</code>，这是单继承的示例。</p>\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>多继承是指一个类可以同时继承自多个类，也就是说一个派生类可以有多个直接基类。</p>\n<p>例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Flyable</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fly</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;I am flying&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Bird</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sing</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Bird is singing&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pigeon</span> : <span class=\"keyword\">public</span> Flyable, <span class=\"keyword\">public</span> Bird &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">coo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Pigeon is cooing&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在上面的代码中，类 <code>Pigeon</code> （鸽子）同时继承自类 <code>Flyable</code> （可飞行）和类 <code>Bird</code>（鸟），这是多继承的示例。</p>\n<p><strong>使用单继承和多继承都有其优缺点，单继承有较好的可维护性和易读性，但缺乏灵活性；多继承具有更高的灵活性，但可能会导致继承层次结构过于复杂和不易维护</strong></p>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}