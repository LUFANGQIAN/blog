---
title: 笔记：类和结构的定义与区别
---

# 笔记：类和结构的定义与区别

## 定义

类和结构是面向对象编程中的两个重要概念，它们是用于定义数据类型和实现相关操作的基本工具之一。下面是类和结构的定义方式及其区别：

#### 类的定义：

类是一种自定义的数据类型，用于表示某个具体对象的属性和行为。类定义了对象的特征和行为，并提供了对它们的操作。类的定义方式通常如下：

```c#
class ClassName
{
    // 类成员的定义
}

```

其中，`class` 是 C# 中定义类的关键字，`ClassName` 是自定义的类名称。在类体内，可以定义类的成员，包括字段、属性、方法、构造函数、静态成员等等。类的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。

#### 结构的定义：

结构是一种自定义的值类型数据类型，用于表示某个数据的属性和行为。与类不同的是，结构是通过值传递而不是引用传递的方式来传递数据。结构的定义方式通常如下：

```c#
struct StructName
{
    // 结构成员的定义
}

```

其中，`struct` 是 C# 中定义结构的关键字，`StructName` 是自定义的结构名称。在结构体体内，可以定义结构的成员，包括字段、属性、方法、构造函数、静态成员等等。结构的成员可以是公共的、私有的或受保护的，通过访问修饰符来控制其可见性和可访问性。

**需要注意的是，结构的大小通常比类小，因为结构体通常是值类型，在栈中分配。此外，结构体通常用于表示简单的数据类型，例如坐标、日期、颜色等等，而类则通常用于表示复杂的对象，例如人、车、房屋等等**



## 类和结构的区别

1.类和结构的默认访问修饰符不同：类的默认访问修饰符是 internal，而结构的默认访问修饰符是 public。

2.类和结构的实例化方式不同：类的实例化需要使用 new 关键字，而结构可以使用 new 关键字，也可以不使用。

3.类和结构的传递方式不同：类是引用类型，传递时传递的是引用的副本；而结构是值类型，传递时传递的是值的副本。

4.类和结构的继承方式不同：类支持单继承和多重继承，而结构只支持单继承。

<!--关于单双继承的定义以及区见“笔记：继承以及单双继承的含义以及区别”-->

5.类和结构的大小不同：由于类的实例通常在堆上分配，所以类的大小可能比结构的大小大很多。



## 对于第三条引用类型不同（值传递和引用传递的区别）的解释

值传递和引用传递是两种不同的数据传递方式，它们的主要区别在于传递的方式和传递数据的副本。

#### 值传递

值传递是指将一个变量的值复制到另一个变量，然后传递该值的副本。在这种情况下，函数或方法中的参数是原始值的副本，对参数的修改不会影响原始值。在值传递中，对于基本数据类型（例如 int、float、double 等）和结构体类型，变量的值被传递给函数或方法，而不是对变量的引用或指针。这意味着在函数或方法中对参数进行更改时，不会影响原始变量的值。

```c++
#include <iostream>

void ModifyValue(int value)
{
    value = 20;
}

int main()
{
    int x = 10;
    std::cout << "原始值：" << x << std::endl; // 输出：原始值：10

    ModifyValue(x);
    std::cout << "修改后的值：" << x << std::endl; // 输出：修改后的值：10

    return 0;
}

```

在上面的代码中，函数 `ModifyValue` 采用了值传递方式，即将变量 `x` 的值复制到函数参数 `value` 中。在函数中对参数 `value` 的更改**不会影响原始变量** `x` **的值。**

#### 引用传递

引用传递是指将变量的引用（或指针）传递给函数或方法，而不是变量的副本。在这种情况下，函数或方法中的参数是变量的引用，对参数的修改会影响原始变量的值。在引用传递中，对于类类型和数组类型，变量的引用被传递给函数或方法，而不是对变量的值进行传递。这意味着在函数或方法中对参数进行更改时，会影响原始变量的值。

```c++
#include <iostream>

void ModifyValue(int& value)
{
    value = 10;
}

int main()
{
    int x = 5;
    std::cout << "原始值：" << x << std::endl; // 输出：原始值：5

    ModifyValue(x);
    std::cout << "修改后的值：" << x << std::endl; // 输出：修改后的值：10

    return 0;
}

```

在上面的代码中，函数 `ModifyValue` 采用了引用传递方式，即将变量 `x` 的引用传递给函数参数 `value` 中。在函数中对参数 `value` 的更改**会影响到原始变量** `x` **的值。**

##### 总结

总的来说，在值传递中，传入函数的是参数的值的一个副本，因此函数对参数进行修改不会影响到原始变量的值。而在引用传递中，传入函数的是参数的引用（地址），函数对参数进行的任何修改都会影响到原始变量的值，因为它们实际上指向同一块内存地址。



